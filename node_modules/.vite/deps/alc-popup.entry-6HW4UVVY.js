import {
  Host,
  h,
  registerInstance
} from "./chunk-S4YNXM4D.js";
import "./chunk-7D4SUZUM.js";

// node_modules/alcance/dist/esm-es5/alc-popup.entry.js
var __assign = function() {
  __assign = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) if (Object.prototype.hasOwnProperty.call(t, i)) e[i] = t[i];
    }
    return e;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = function(e, t, n, r) {
  function i(e2) {
    return e2 instanceof n ? e2 : new n(function(t2) {
      t2(e2);
    });
  }
  return new (n || (n = Promise))(function(n2, o) {
    function a(e2) {
      try {
        u(r.next(e2));
      } catch (e3) {
        o(e3);
      }
    }
    function s(e2) {
      try {
        u(r["throw"](e2));
      } catch (e3) {
        o(e3);
      }
    }
    function u(e2) {
      e2.done ? n2(e2.value) : i(e2.value).then(a, s);
    }
    u((r = r.apply(e, t || [])).next());
  });
};
var __generator = function(e, t) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, a;
  return a = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(e2) {
    return function(t2) {
      return u([e2, t2]);
    };
  }
  function u(s2) {
    if (r) throw new TypeError("Generator is already executing.");
    while (a && (a = 0, s2[0] && (n = 0)), n) try {
      if (r = 1, i && (o = s2[0] & 2 ? i["return"] : s2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, s2[1])).done) return o;
      if (i = 0, o) s2 = [s2[0] & 2, o.value];
      switch (s2[0]) {
        case 0:
        case 1:
          o = s2;
          break;
        case 4:
          n.label++;
          return { value: s2[1], done: false };
        case 5:
          n.label++;
          i = s2[1];
          s2 = [0];
          continue;
        case 7:
          s2 = n.ops.pop();
          n.trys.pop();
          continue;
        default:
          if (!(o = n.trys, o = o.length > 0 && o[o.length - 1]) && (s2[0] === 6 || s2[0] === 2)) {
            n = 0;
            continue;
          }
          if (s2[0] === 3 && (!o || s2[1] > o[0] && s2[1] < o[3])) {
            n.label = s2[1];
            break;
          }
          if (s2[0] === 6 && n.label < o[1]) {
            n.label = o[1];
            o = s2;
            break;
          }
          if (o && n.label < o[2]) {
            n.label = o[2];
            n.ops.push(s2);
            break;
          }
          if (o[2]) n.ops.pop();
          n.trys.pop();
          continue;
      }
      s2 = t.call(e, n);
    } catch (e2) {
      s2 = [6, e2];
      i = 0;
    } finally {
      r = o = 0;
    }
    if (s2[0] & 5) throw s2[1];
    return { value: s2[0] ? s2[1] : void 0, done: true };
  }
};
var __rest = function(e, t) {
  var n = {};
  for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0) n[r] = e[r];
  if (e != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++) {
    if (t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i])) n[r[i]] = e[r[i]];
  }
  return n;
};
var __spreadArray = function(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++) {
    if (o || !(r in t)) {
      if (!o) o = Array.prototype.slice.call(t, 0, r);
      o[r] = t[r];
    }
  }
  return e.concat(o || Array.prototype.slice.call(t));
};
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = function(e) {
  return { x: e, y: e };
};
var oppositeSideMap = { left: "right", right: "left", bottom: "top", top: "bottom" };
var oppositeAlignmentMap = { start: "end", end: "start" };
function clamp(e, t, n) {
  return max(e, min(t, n));
}
function evaluate(e, t) {
  return typeof e === "function" ? e(t) : e;
}
function getSide(e) {
  return e.split("-")[0];
}
function getAlignment(e) {
  return e.split("-")[1];
}
function getOppositeAxis(e) {
  return e === "x" ? "y" : "x";
}
function getAxisLength(e) {
  return e === "y" ? "height" : "width";
}
function getSideAxis(e) {
  return ["top", "bottom"].includes(getSide(e)) ? "y" : "x";
}
function getAlignmentAxis(e) {
  return getOppositeAxis(getSideAxis(e));
}
function getAlignmentSides(e, t, n) {
  if (n === void 0) {
    n = false;
  }
  var r = getAlignment(e);
  var i = getAlignmentAxis(e);
  var o = getAxisLength(i);
  var a = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  if (t.reference[o] > t.floating[o]) {
    a = getOppositePlacement(a);
  }
  return [a, getOppositePlacement(a)];
}
function getExpandedPlacements(e) {
  var t = getOppositePlacement(e);
  return [getOppositeAlignmentPlacement(e), t, getOppositeAlignmentPlacement(t)];
}
function getOppositeAlignmentPlacement(e) {
  return e.replace(/start|end/g, function(e2) {
    return oppositeAlignmentMap[e2];
  });
}
function getSideList(e, t, n) {
  var r = ["left", "right"];
  var i = ["right", "left"];
  var o = ["top", "bottom"];
  var a = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      if (n) return t ? i : r;
      return t ? r : i;
    case "left":
    case "right":
      return t ? o : a;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(e, t, n, r) {
  var i = getAlignment(e);
  var o = getSideList(getSide(e), n === "start", r);
  if (i) {
    o = o.map(function(e2) {
      return e2 + "-" + i;
    });
    if (t) {
      o = o.concat(o.map(getOppositeAlignmentPlacement));
    }
  }
  return o;
}
function getOppositePlacement(e) {
  return e.replace(/left|right|bottom|top/g, function(e2) {
    return oppositeSideMap[e2];
  });
}
function expandPaddingObject(e) {
  return __assign({ top: 0, right: 0, bottom: 0, left: 0 }, e);
}
function getPaddingObject(e) {
  return typeof e !== "number" ? expandPaddingObject(e) : { top: e, right: e, bottom: e, left: e };
}
function rectToClientRect(e) {
  return __assign(__assign({}, e), { top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height });
}
function computeCoordsFromPlacement(e, t, n) {
  var r = e.reference, i = e.floating;
  var o = getSideAxis(t);
  var a = getAlignmentAxis(t);
  var s = getAxisLength(a);
  var u = getSide(t);
  var c = o === "y";
  var f = r.x + r.width / 2 - i.width / 2;
  var l = r.y + r.height / 2 - i.height / 2;
  var v = r[s] / 2 - i[s] / 2;
  var d;
  switch (u) {
    case "top":
      d = { x: f, y: r.y - i.height };
      break;
    case "bottom":
      d = { x: f, y: r.y + r.height };
      break;
    case "right":
      d = { x: r.x + r.width, y: l };
      break;
    case "left":
      d = { x: r.x - i.width, y: l };
      break;
    default:
      d = { x: r.x, y: r.y };
  }
  switch (getAlignment(t)) {
    case "start":
      d[a] -= v * (n && c ? -1 : 1);
      break;
    case "end":
      d[a] += v * (n && c ? -1 : 1);
      break;
  }
  return d;
}
var computePosition$1 = function(e, t, n) {
  return __awaiter(void 0, void 0, void 0, function() {
    var r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, A, O, C, S, P, R;
    var E, N;
    return __generator(this, function(T) {
      switch (T.label) {
        case 0:
          r = n.placement, i = r === void 0 ? "bottom" : r, o = n.strategy, a = o === void 0 ? "absolute" : o, s = n.middleware, u = s === void 0 ? [] : s, c = n.platform;
          f = u.filter(Boolean);
          return [4, c.isRTL == null ? void 0 : c.isRTL(t)];
        case 1:
          l = T.sent();
          return [4, c.getElementRects({ reference: e, floating: t, strategy: a })];
        case 2:
          v = T.sent();
          d = computeCoordsFromPlacement(v, i, l), g = d.x, m = d.y;
          p = i;
          h2 = {};
          _ = 0;
          w = 0;
          T.label = 3;
        case 3:
          if (!(w < f.length)) return [3, 11];
          b = f[w], x = b.name, y = b.fn;
          return [4, y({ x: g, y: m, initialPlacement: i, placement: p, strategy: a, middlewareData: h2, rects: v, platform: c, elements: { reference: e, floating: t } })];
        case 4:
          A = T.sent(), O = A.x, C = A.y, S = A.data, P = A.reset;
          g = O != null ? O : g;
          m = C != null ? C : m;
          h2 = __assign(__assign({}, h2), (E = {}, E[x] = __assign(__assign({}, h2[x]), S), E));
          if (!(P && _ <= 50)) return [3, 10];
          _++;
          if (!(typeof P === "object")) return [3, 9];
          if (P.placement) {
            p = P.placement;
          }
          if (!P.rects) return [3, 8];
          if (!(P.rects === true)) return [3, 6];
          return [4, c.getElementRects({ reference: e, floating: t, strategy: a })];
        case 5:
          R = T.sent();
          return [3, 7];
        case 6:
          R = P.rects;
          T.label = 7;
        case 7:
          v = R;
          T.label = 8;
        case 8:
          N = computeCoordsFromPlacement(v, p, l), g = N.x, m = N.y;
          T.label = 9;
        case 9:
          w = -1;
          return [3, 10];
        case 10:
          w++;
          return [3, 3];
        case 11:
          return [2, { x: g, y: m, placement: p, strategy: a, middlewareData: h2 }];
      }
    });
  });
};
function detectOverflow(e, t) {
  return __awaiter(this, void 0, void 0, function() {
    var n, r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, A, O, C, S, P, R, E, N, T, k, L, M, W;
    var D;
    return __generator(this, function(B) {
      switch (B.label) {
        case 0:
          if (t === void 0) {
            t = {};
          }
          r = e.x, i = e.y, o = e.platform, a = e.rects, s = e.elements, u = e.strategy;
          c = evaluate(t, e), f = c.boundary, l = f === void 0 ? "clippingAncestors" : f, v = c.rootBoundary, d = v === void 0 ? "viewport" : v, g = c.elementContext, m = g === void 0 ? "floating" : g, p = c.altBoundary, h2 = p === void 0 ? false : p, _ = c.padding, w = _ === void 0 ? 0 : _;
          b = getPaddingObject(w);
          x = m === "floating" ? "reference" : "floating";
          y = s[h2 ? x : m];
          O = rectToClientRect;
          S = (C = o).getClippingRect;
          D = {};
          return [4, o.isElement == null ? void 0 : o.isElement(y)];
        case 1:
          if (!((n = B.sent()) != null ? n : true)) return [3, 2];
          P = y;
          return [3, 5];
        case 2:
          R = y.contextElement;
          if (R) return [3, 4];
          return [4, o.getDocumentElement == null ? void 0 : o.getDocumentElement(s.floating)];
        case 3:
          R = B.sent();
          B.label = 4;
        case 4:
          P = R;
          B.label = 5;
        case 5:
          return [4, S.apply(C, [(D.element = P, D.boundary = l, D.rootBoundary = d, D.strategy = u, D)])];
        case 6:
          A = O.apply(void 0, [B.sent()]);
          E = m === "floating" ? __assign(__assign({}, a.floating), { x: r, y: i }) : a.reference;
          return [4, o.getOffsetParent == null ? void 0 : o.getOffsetParent(s.floating)];
        case 7:
          N = B.sent();
          return [4, o.isElement == null ? void 0 : o.isElement(N)];
        case 8:
          if (!B.sent()) return [3, 10];
          return [4, o.getScale == null ? void 0 : o.getScale(N)];
        case 9:
          k = B.sent() || { x: 1, y: 1 };
          return [3, 11];
        case 10:
          k = { x: 1, y: 1 };
          B.label = 11;
        case 11:
          T = k;
          M = rectToClientRect;
          if (!o.convertOffsetParentRelativeRectToViewportRelativeRect) return [3, 13];
          return [4, o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: E, offsetParent: N, strategy: u })];
        case 12:
          W = B.sent();
          return [3, 14];
        case 13:
          W = E;
          B.label = 14;
        case 14:
          L = M.apply(void 0, [W]);
          return [2, { top: (A.top - L.top + b.top) / T.y, bottom: (L.bottom - A.bottom + b.bottom) / T.y, left: (A.left - L.left + b.left) / T.x, right: (L.right - A.right + b.right) / T.x }];
      }
    });
  });
}
var arrow = function(e) {
  return { name: "arrow", options: e, fn: function(t) {
    return __awaiter(this, void 0, void 0, function() {
      var n, r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, A, O, C, S, P, R, E, N, T, k, L, M, W, D;
      var B, F;
      return __generator(this, function(j) {
        switch (j.label) {
          case 0:
            n = t.x, r = t.y, i = t.placement, o = t.rects, a = t.platform, s = t.elements, u = t.middlewareData;
            c = evaluate(e, t) || {}, f = c.element, l = c.padding, v = l === void 0 ? 0 : l;
            if (f == null) {
              return [2, {}];
            }
            d = getPaddingObject(v);
            g = { x: n, y: r };
            m = getAlignmentAxis(i);
            p = getAxisLength(m);
            return [4, a.getDimensions(f)];
          case 1:
            h2 = j.sent();
            _ = m === "y";
            w = _ ? "top" : "left";
            b = _ ? "bottom" : "right";
            x = _ ? "clientHeight" : "clientWidth";
            y = o.reference[p] + o.reference[m] - g[m] - o.floating[p];
            A = g[m] - o.reference[m];
            return [4, a.getOffsetParent == null ? void 0 : a.getOffsetParent(f)];
          case 2:
            O = j.sent();
            C = O ? O[x] : 0;
            S = !C;
            if (S) return [3, 4];
            return [4, a.isElement == null ? void 0 : a.isElement(O)];
          case 3:
            S = !j.sent();
            j.label = 4;
          case 4:
            if (S) {
              C = s.floating[x] || o.floating[p];
            }
            P = y / 2 - A / 2;
            R = C / 2 - h2[p] / 2 - 1;
            E = min(d[w], R);
            N = min(d[b], R);
            T = E;
            k = C - h2[p] - N;
            L = C / 2 - h2[p] / 2 + P;
            M = clamp(T, L, k);
            W = !u.arrow && getAlignment(i) != null && L != M && o.reference[p] / 2 - (L < T ? E : N) - h2[p] / 2 < 0;
            D = W ? L < T ? L - T : L - k : 0;
            return [2, (B = {}, B[m] = g[m] + D, B.data = __assign((F = {}, F[m] = M, F.centerOffset = L - M - D, F), W && { alignmentOffset: D }), B.reset = W, B)];
        }
      });
    });
  } };
};
var flip = function(e) {
  if (e === void 0) {
    e = {};
  }
  return { name: "flip", options: e, fn: function(t) {
    return __awaiter(this, void 0, void 0, function() {
      var n, r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, A, O, C, S, P, R, E, N, T, k, L, M, W, D, B, F;
      return __generator(this, function(j) {
        switch (j.label) {
          case 0:
            i = t.placement, o = t.middlewareData, a = t.rects, s = t.initialPlacement, u = t.platform, c = t.elements;
            f = evaluate(e, t), l = f.mainAxis, v = l === void 0 ? true : l, d = f.crossAxis, g = d === void 0 ? true : d, m = f.fallbackPlacements, p = f.fallbackStrategy, h2 = p === void 0 ? "bestFit" : p, _ = f.fallbackAxisSideDirection, w = _ === void 0 ? "none" : _, b = f.flipAlignment, x = b === void 0 ? true : b, y = __rest(f, ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"]);
            if ((n = o.arrow) != null && n.alignmentOffset) {
              return [2, {}];
            }
            A = getSide(i);
            O = getSide(s) === s;
            return [4, u.isRTL == null ? void 0 : u.isRTL(c.floating)];
          case 1:
            C = j.sent();
            S = m || (O || !x ? [getOppositePlacement(s)] : getExpandedPlacements(s));
            if (!m && w !== "none") {
              S.push.apply(S, getOppositeAxisPlacements(s, x, w, C));
            }
            P = __spreadArray([s], S, true);
            return [4, detectOverflow(t, y)];
          case 2:
            R = j.sent();
            E = [];
            N = ((r = o.flip) == null ? void 0 : r.overflows) || [];
            if (v) {
              E.push(R[A]);
            }
            if (g) {
              T = getAlignmentSides(i, a, C);
              E.push(R[T[0]], R[T[1]]);
            }
            N = __spreadArray(__spreadArray([], N, true), [{ placement: i, overflows: E }], false);
            if (!E.every(function(e2) {
              return e2 <= 0;
            })) {
              M = (((k = o.flip) == null ? void 0 : k.index) || 0) + 1;
              W = P[M];
              if (W) {
                return [2, { data: { index: M, overflows: N }, reset: { placement: W } }];
              }
              D = (L = N.filter(function(e2) {
                return e2.overflows[0] <= 0;
              }).sort(function(e2, t2) {
                return e2.overflows[1] - t2.overflows[1];
              })[0]) == null ? void 0 : L.placement;
              if (!D) {
                switch (h2) {
                  case "bestFit": {
                    F = (B = N.map(function(e2) {
                      return [e2.placement, e2.overflows.filter(function(e3) {
                        return e3 > 0;
                      }).reduce(function(e3, t2) {
                        return e3 + t2;
                      }, 0)];
                    }).sort(function(e2, t2) {
                      return e2[1] - t2[1];
                    })[0]) == null ? void 0 : B[0];
                    if (F) {
                      D = F;
                    }
                    break;
                  }
                  case "initialPlacement":
                    D = s;
                    break;
                }
              }
              if (i !== D) {
                return [2, { reset: { placement: D } }];
              }
            }
            return [2, {}];
        }
      });
    });
  } };
};
function convertValueToCoords(e, t) {
  return __awaiter(this, void 0, void 0, function() {
    var n, r, i, o, a, s, u, c, f, l, v, d, g, m;
    return __generator(this, function(p) {
      switch (p.label) {
        case 0:
          n = e.placement, r = e.platform, i = e.elements;
          return [4, r.isRTL == null ? void 0 : r.isRTL(i.floating)];
        case 1:
          o = p.sent();
          a = getSide(n);
          s = getAlignment(n);
          u = getSideAxis(n) === "y";
          c = ["left", "top"].includes(a) ? -1 : 1;
          f = o && u ? -1 : 1;
          l = evaluate(t, e);
          v = typeof l === "number" ? { mainAxis: l, crossAxis: 0, alignmentAxis: null } : __assign({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, l), d = v.mainAxis, g = v.crossAxis, m = v.alignmentAxis;
          if (s && typeof m === "number") {
            g = s === "end" ? m * -1 : m;
          }
          return [2, u ? { x: g * f, y: d * c } : { x: d * c, y: g * f }];
      }
    });
  });
}
var offset = function(e) {
  if (e === void 0) {
    e = 0;
  }
  return { name: "offset", options: e, fn: function(t) {
    return __awaiter(this, void 0, void 0, function() {
      var n, r, i;
      return __generator(this, function(o) {
        switch (o.label) {
          case 0:
            n = t.x, r = t.y;
            return [4, convertValueToCoords(t, e)];
          case 1:
            i = o.sent();
            return [2, { x: n + i.x, y: r + i.y, data: i }];
        }
      });
    });
  } };
};
var shift = function(e) {
  if (e === void 0) {
    e = {};
  }
  return { name: "shift", options: e, fn: function(t) {
    return __awaiter(this, void 0, void 0, function() {
      var n, r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, w, b, A, O, C;
      var S;
      return __generator(this, function(P) {
        switch (P.label) {
          case 0:
            n = t.x, r = t.y, i = t.placement;
            o = evaluate(e, t), a = o.mainAxis, s = a === void 0 ? true : a, u = o.crossAxis, c = u === void 0 ? false : u, f = o.limiter, l = f === void 0 ? { fn: function(e2) {
              var t2 = e2.x, n2 = e2.y;
              return { x: t2, y: n2 };
            } } : f, v = __rest(o, ["mainAxis", "crossAxis", "limiter"]);
            d = { x: n, y: r };
            return [4, detectOverflow(t, v)];
          case 1:
            g = P.sent();
            m = getSideAxis(getSide(i));
            p = getOppositeAxis(m);
            h2 = d[p];
            _ = d[m];
            if (s) {
              w = p === "y" ? "top" : "left";
              b = p === "y" ? "bottom" : "right";
              x = h2 + g[w];
              y = h2 - g[b];
              h2 = clamp(x, h2, y);
            }
            if (c) {
              w = m === "y" ? "top" : "left";
              b = m === "y" ? "bottom" : "right";
              A = _ + g[w];
              O = _ - g[b];
              _ = clamp(A, _, O);
            }
            C = l.fn(__assign(__assign({}, t), (S = {}, S[p] = h2, S[m] = _, S)));
            return [2, __assign(__assign({}, C), { data: { x: C.x - n, y: C.y - r } })];
        }
      });
    });
  } };
};
var size = function(e) {
  if (e === void 0) {
    e = {};
  }
  return { name: "size", options: e, fn: function(t) {
    return __awaiter(this, void 0, void 0, function() {
      var n, r, i, o, a, s, u, c, f, l, v, d, g, m, p, h2, _, w, b, x, y, A, O, C, S, P, R, E, N, T;
      return __generator(this, function(k) {
        switch (k.label) {
          case 0:
            n = t.placement, r = t.rects, i = t.platform, o = t.elements;
            a = evaluate(e, t), s = a.apply, u = s === void 0 ? function() {
            } : s, c = __rest(a, ["apply"]);
            return [4, detectOverflow(t, c)];
          case 1:
            f = k.sent();
            l = getSide(n);
            v = getAlignment(n);
            d = getSideAxis(n) === "y";
            g = r.floating, m = g.width, p = g.height;
            if (!(l === "top" || l === "bottom")) return [3, 3];
            h2 = l;
            w = v;
            return [4, i.isRTL == null ? void 0 : i.isRTL(o.floating)];
          case 2:
            _ = w === (k.sent() ? "start" : "end") ? "left" : "right";
            return [3, 4];
          case 3:
            _ = l;
            h2 = v === "end" ? "top" : "bottom";
            k.label = 4;
          case 4:
            b = p - f[h2];
            x = m - f[_];
            y = !t.middlewareData.shift;
            A = b;
            O = x;
            if (d) {
              C = m - f.left - f.right;
              O = v || y ? min(x, C) : C;
            } else {
              S = p - f.top - f.bottom;
              A = v || y ? min(b, S) : S;
            }
            if (y && !v) {
              P = max(f.left, 0);
              R = max(f.right, 0);
              E = max(f.top, 0);
              N = max(f.bottom, 0);
              if (d) {
                O = m - 2 * (P !== 0 || R !== 0 ? P + R : max(f.left, f.right));
              } else {
                A = p - 2 * (E !== 0 || N !== 0 ? E + N : max(f.top, f.bottom));
              }
            }
            return [4, u(__assign(__assign({}, t), { availableWidth: O, availableHeight: A }))];
          case 5:
            k.sent();
            return [4, i.getDimensions(o.floating)];
          case 6:
            T = k.sent();
            if (m !== T.width || p !== T.height) {
              return [2, { reset: { rects: true } }];
            }
            return [2, {}];
        }
      });
    });
  } };
};
function getNodeName(e) {
  if (isNode(e)) {
    return (e.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(e) {
  var t;
  return (e == null ? void 0 : (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function getDocumentElement(e) {
  var t;
  return (t = (isNode(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function isNode(e) {
  return e instanceof Node || e instanceof getWindow(e).Node;
}
function isElement(e) {
  return e instanceof Element || e instanceof getWindow(e).Element;
}
function isHTMLElement(e) {
  return e instanceof HTMLElement || e instanceof getWindow(e).HTMLElement;
}
function isShadowRoot(e) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return e instanceof ShadowRoot || e instanceof getWindow(e).ShadowRoot;
}
function isOverflowElement(e) {
  var t = getComputedStyle(e), n = t.overflow, r = t.overflowX, i = t.overflowY, o = t.display;
  return /auto|scroll|overlay|hidden|clip/.test(n + i + r) && !["inline", "contents"].includes(o);
}
function isTableElement(e) {
  return ["table", "td", "th"].includes(getNodeName(e));
}
function isContainingBlock(e) {
  var t = isWebKit();
  var n = getComputedStyle(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || ["transform", "perspective", "filter"].some(function(e2) {
    return (n.willChange || "").includes(e2);
  }) || ["paint", "layout", "strict", "content"].some(function(e2) {
    return (n.contain || "").includes(e2);
  });
}
function getContainingBlock(e) {
  var t = getParentNode(e);
  while (isHTMLElement(t) && !isLastTraversableNode(t)) {
    if (isContainingBlock(t)) {
      return t;
    } else {
      t = getParentNode(t);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(e) {
  return ["html", "body", "#document"].includes(getNodeName(e));
}
function getComputedStyle(e) {
  return getWindow(e).getComputedStyle(e);
}
function getNodeScroll(e) {
  if (isElement(e)) {
    return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
  }
  return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function getParentNode(e) {
  if (getNodeName(e) === "html") {
    return e;
  }
  var t = e.assignedSlot || e.parentNode || isShadowRoot(e) && e.host || getDocumentElement(e);
  return isShadowRoot(t) ? t.host : t;
}
function getNearestOverflowAncestor(e) {
  var t = getParentNode(e);
  if (isLastTraversableNode(t)) {
    return e.ownerDocument ? e.ownerDocument.body : e.body;
  }
  if (isHTMLElement(t) && isOverflowElement(t)) {
    return t;
  }
  return getNearestOverflowAncestor(t);
}
function getOverflowAncestors(e, t, n) {
  var r;
  if (t === void 0) {
    t = [];
  }
  if (n === void 0) {
    n = true;
  }
  var i = getNearestOverflowAncestor(e);
  var o = i === ((r = e.ownerDocument) == null ? void 0 : r.body);
  var a = getWindow(i);
  if (o) {
    return t.concat(a, a.visualViewport || [], isOverflowElement(i) ? i : [], a.frameElement && n ? getOverflowAncestors(a.frameElement) : []);
  }
  return t.concat(i, getOverflowAncestors(i, [], n));
}
function getCssDimensions(e) {
  var t = getComputedStyle(e);
  var n = parseFloat(t.width) || 0;
  var r = parseFloat(t.height) || 0;
  var i = isHTMLElement(e);
  var o = i ? e.offsetWidth : n;
  var a = i ? e.offsetHeight : r;
  var s = round(n) !== o || round(r) !== a;
  if (s) {
    n = o;
    r = a;
  }
  return { width: n, height: r, $: s };
}
function unwrapElement(e) {
  return !isElement(e) ? e.contextElement : e;
}
function getScale(e) {
  var t = unwrapElement(e);
  if (!isHTMLElement(t)) {
    return createCoords(1);
  }
  var n = t.getBoundingClientRect();
  var r = getCssDimensions(t), i = r.width, o = r.height, a = r.$;
  var s = (a ? round(n.width) : n.width) / i;
  var u = (a ? round(n.height) : n.height) / o;
  if (!s || !Number.isFinite(s)) {
    s = 1;
  }
  if (!u || !Number.isFinite(u)) {
    u = 1;
  }
  return { x: s, y: u };
}
var noOffsets = createCoords(0);
function getVisualOffsets(e) {
  var t = getWindow(e);
  if (!isWebKit() || !t.visualViewport) {
    return noOffsets;
  }
  return { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop };
}
function shouldAddVisualOffsets(e, t, n) {
  if (t === void 0) {
    t = false;
  }
  if (!n || t && n !== getWindow(e)) {
    return false;
  }
  return t;
}
function getBoundingClientRect(e, t, n, r) {
  if (t === void 0) {
    t = false;
  }
  if (n === void 0) {
    n = false;
  }
  var i = e.getBoundingClientRect();
  var o = unwrapElement(e);
  var a = createCoords(1);
  if (t) {
    if (r) {
      if (isElement(r)) {
        a = getScale(r);
      }
    } else {
      a = getScale(e);
    }
  }
  var s = shouldAddVisualOffsets(o, n, r) ? getVisualOffsets(o) : createCoords(0);
  var u = (i.left + s.x) / a.x;
  var c = (i.top + s.y) / a.y;
  var f = i.width / a.x;
  var l = i.height / a.y;
  if (o) {
    var v = getWindow(o);
    var d = r && isElement(r) ? getWindow(r) : r;
    var g = v.frameElement;
    while (g && r && d !== v) {
      var m = getScale(g);
      var p = g.getBoundingClientRect();
      var h2 = getComputedStyle(g);
      var _ = p.left + (g.clientLeft + parseFloat(h2.paddingLeft)) * m.x;
      var w = p.top + (g.clientTop + parseFloat(h2.paddingTop)) * m.y;
      u *= m.x;
      c *= m.y;
      f *= m.x;
      l *= m.y;
      u += _;
      c += w;
      g = getWindow(g).frameElement;
    }
  }
  return rectToClientRect({ width: f, height: l, x: u, y: c });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(e) {
  var t = e.rect, n = e.offsetParent, r = e.strategy;
  var i = isHTMLElement(n);
  var o = getDocumentElement(n);
  if (n === o) {
    return t;
  }
  var a = { scrollLeft: 0, scrollTop: 0 };
  var s = createCoords(1);
  var u = createCoords(0);
  if (i || !i && r !== "fixed") {
    if (getNodeName(n) !== "body" || isOverflowElement(o)) {
      a = getNodeScroll(n);
    }
    if (isHTMLElement(n)) {
      var c = getBoundingClientRect(n);
      s = getScale(n);
      u.x = c.x + n.clientLeft;
      u.y = c.y + n.clientTop;
    }
  }
  return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - a.scrollLeft * s.x + u.x, y: t.y * s.y - a.scrollTop * s.y + u.y };
}
function getClientRects(e) {
  return Array.from(e.getClientRects());
}
function getWindowScrollBarX(e) {
  return getBoundingClientRect(getDocumentElement(e)).left + getNodeScroll(e).scrollLeft;
}
function getDocumentRect(e) {
  var t = getDocumentElement(e);
  var n = getNodeScroll(e);
  var r = e.ownerDocument.body;
  var i = max(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth);
  var o = max(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  var a = -n.scrollLeft + getWindowScrollBarX(e);
  var s = -n.scrollTop;
  if (getComputedStyle(r).direction === "rtl") {
    a += max(t.clientWidth, r.clientWidth) - i;
  }
  return { width: i, height: o, x: a, y: s };
}
function getViewportRect(e, t) {
  var n = getWindow(e);
  var r = getDocumentElement(e);
  var i = n.visualViewport;
  var o = r.clientWidth;
  var a = r.clientHeight;
  var s = 0;
  var u = 0;
  if (i) {
    o = i.width;
    a = i.height;
    var c = isWebKit();
    if (!c || c && t === "fixed") {
      s = i.offsetLeft;
      u = i.offsetTop;
    }
  }
  return { width: o, height: a, x: s, y: u };
}
function getInnerBoundingClientRect(e, t) {
  var n = getBoundingClientRect(e, true, t === "fixed");
  var r = n.top + e.clientTop;
  var i = n.left + e.clientLeft;
  var o = isHTMLElement(e) ? getScale(e) : createCoords(1);
  var a = e.clientWidth * o.x;
  var s = e.clientHeight * o.y;
  var u = i * o.x;
  var c = r * o.y;
  return { width: a, height: s, x: u, y: c };
}
function getClientRectFromClippingAncestor(e, t, n) {
  var r;
  if (t === "viewport") {
    r = getViewportRect(e, n);
  } else if (t === "document") {
    r = getDocumentRect(getDocumentElement(e));
  } else if (isElement(t)) {
    r = getInnerBoundingClientRect(t, n);
  } else {
    var i = getVisualOffsets(e);
    r = __assign(__assign({}, t), { x: t.x - i.x, y: t.y - i.y });
  }
  return rectToClientRect(r);
}
function hasFixedPositionAncestor(e, t) {
  var n = getParentNode(e);
  if (n === t || !isElement(n) || isLastTraversableNode(n)) {
    return false;
  }
  return getComputedStyle(n).position === "fixed" || hasFixedPositionAncestor(n, t);
}
function getClippingElementAncestors(e, t) {
  var n = t.get(e);
  if (n) {
    return n;
  }
  var r = getOverflowAncestors(e, [], false).filter(function(e2) {
    return isElement(e2) && getNodeName(e2) !== "body";
  });
  var i = null;
  var o = getComputedStyle(e).position === "fixed";
  var a = o ? getParentNode(e) : e;
  while (isElement(a) && !isLastTraversableNode(a)) {
    var s = getComputedStyle(a);
    var u = isContainingBlock(a);
    if (!u && s.position === "fixed") {
      i = null;
    }
    var c = o ? !u && !i : !u && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || isOverflowElement(a) && !u && hasFixedPositionAncestor(e, a);
    if (c) {
      r = r.filter(function(e2) {
        return e2 !== a;
      });
    } else {
      i = s;
    }
    a = getParentNode(a);
  }
  t.set(e, r);
  return r;
}
function getClippingRect(e) {
  var t = e.element, n = e.boundary, r = e.rootBoundary, i = e.strategy;
  var o = n === "clippingAncestors" ? getClippingElementAncestors(t, this._c) : [].concat(n);
  var a = __spreadArray(__spreadArray([], o, true), [r], false);
  var s = a[0];
  var u = a.reduce(function(e2, n2) {
    var r2 = getClientRectFromClippingAncestor(t, n2, i);
    e2.top = max(r2.top, e2.top);
    e2.right = min(r2.right, e2.right);
    e2.bottom = min(r2.bottom, e2.bottom);
    e2.left = max(r2.left, e2.left);
    return e2;
  }, getClientRectFromClippingAncestor(t, s, i));
  return { width: u.right - u.left, height: u.bottom - u.top, x: u.left, y: u.top };
}
function getDimensions(e) {
  return getCssDimensions(e);
}
function getRectRelativeToOffsetParent(e, t, n) {
  var r = isHTMLElement(t);
  var i = getDocumentElement(t);
  var o = n === "fixed";
  var a = getBoundingClientRect(e, true, o, t);
  var s = { scrollLeft: 0, scrollTop: 0 };
  var u = createCoords(0);
  if (r || !r && !o) {
    if (getNodeName(t) !== "body" || isOverflowElement(i)) {
      s = getNodeScroll(t);
    }
    if (r) {
      var c = getBoundingClientRect(t, true, o, t);
      u.x = c.x + t.clientLeft;
      u.y = c.y + t.clientTop;
    } else if (i) {
      u.x = getWindowScrollBarX(i);
    }
  }
  return { x: a.left + s.scrollLeft - u.x, y: a.top + s.scrollTop - u.y, width: a.width, height: a.height };
}
function getTrueOffsetParent(e, t) {
  if (!isHTMLElement(e) || getComputedStyle(e).position === "fixed") {
    return null;
  }
  if (t) {
    return t(e);
  }
  return e.offsetParent;
}
function getOffsetParent(e, t) {
  var n = getWindow(e);
  if (!isHTMLElement(e)) {
    return n;
  }
  var r = getTrueOffsetParent(e, t);
  while (r && isTableElement(r) && getComputedStyle(r).position === "static") {
    r = getTrueOffsetParent(r, t);
  }
  if (r && (getNodeName(r) === "html" || getNodeName(r) === "body" && getComputedStyle(r).position === "static" && !isContainingBlock(r))) {
    return n;
  }
  return r || getContainingBlock(e) || n;
}
var getElementRects = function(e) {
  return __awaiter(this, void 0, void 0, function() {
    var t, n, r, i, o, a, s, u;
    var c;
    return __generator(this, function(f) {
      switch (f.label) {
        case 0:
          t = e.reference, n = e.floating, r = e.strategy;
          i = this.getOffsetParent || getOffsetParent;
          o = this.getDimensions;
          c = {};
          a = getRectRelativeToOffsetParent;
          s = [t];
          return [4, i(n)];
        case 1:
          c.reference = a.apply(void 0, s.concat([f.sent(), r]));
          u = [{ x: 0, y: 0 }];
          return [4, o(n)];
        case 2:
          return [2, (c.floating = __assign.apply(void 0, u.concat([f.sent()])), c)];
      }
    });
  });
};
function isRTL(e) {
  return getComputedStyle(e).direction === "rtl";
}
var platform = { convertOffsetParentRelativeRectToViewportRelativeRect, getDocumentElement, getClippingRect, getOffsetParent, getElementRects, getClientRects, getDimensions, getScale, isElement, isRTL };
function observeMove(e, t) {
  var n = null;
  var r;
  var i = getDocumentElement(e);
  function o() {
    clearTimeout(r);
    n && n.disconnect();
    n = null;
  }
  function a(s, u) {
    if (s === void 0) {
      s = false;
    }
    if (u === void 0) {
      u = 1;
    }
    o();
    var c = e.getBoundingClientRect(), f = c.left, l = c.top, v = c.width, d = c.height;
    if (!s) {
      t();
    }
    if (!v || !d) {
      return;
    }
    var g = floor(l);
    var m = floor(i.clientWidth - (f + v));
    var p = floor(i.clientHeight - (l + d));
    var h2 = floor(f);
    var _ = -g + "px " + -m + "px " + -p + "px " + -h2 + "px";
    var w = { rootMargin: _, threshold: max(0, min(1, u)) || 1 };
    var b = true;
    function x(e2) {
      var t2 = e2[0].intersectionRatio;
      if (t2 !== u) {
        if (!b) {
          return a();
        }
        if (!t2) {
          r = setTimeout(function() {
            a(false, 1e-7);
          }, 100);
        } else {
          a(false, t2);
        }
      }
      b = false;
    }
    try {
      n = new IntersectionObserver(x, __assign(__assign({}, w), { root: i.ownerDocument }));
    } catch (e2) {
      n = new IntersectionObserver(x, w);
    }
    n.observe(e);
  }
  a(true);
  return o;
}
function autoUpdate(e, t, n, r) {
  if (r === void 0) {
    r = {};
  }
  var i = r.ancestorScroll, o = i === void 0 ? true : i, a = r.ancestorResize, s = a === void 0 ? true : a, u = r.elementResize, c = u === void 0 ? typeof ResizeObserver === "function" : u, f = r.layoutShift, l = f === void 0 ? typeof IntersectionObserver === "function" : f, v = r.animationFrame, d = v === void 0 ? false : v;
  var g = unwrapElement(e);
  var m = o || s ? __spreadArray(__spreadArray([], g ? getOverflowAncestors(g) : [], true), getOverflowAncestors(t), true) : [];
  m.forEach(function(e2) {
    o && e2.addEventListener("scroll", n, { passive: true });
    s && e2.addEventListener("resize", n);
  });
  var p = g && l ? observeMove(g, n) : null;
  var h2 = -1;
  var _ = null;
  if (c) {
    _ = new ResizeObserver(function(e2) {
      var r2 = e2[0];
      if (r2 && r2.target === g && _) {
        _.unobserve(t);
        cancelAnimationFrame(h2);
        h2 = requestAnimationFrame(function() {
          _ && _.observe(t);
        });
      }
      n();
    });
    if (g && !d) {
      _.observe(g);
    }
    _.observe(t);
  }
  var w;
  var b = d ? getBoundingClientRect(e) : null;
  if (d) {
    x();
  }
  function x() {
    var t2 = getBoundingClientRect(e);
    if (b && (t2.x !== b.x || t2.y !== b.y || t2.width !== b.width || t2.height !== b.height)) {
      n();
    }
    b = t2;
    w = requestAnimationFrame(x);
  }
  n();
  return function() {
    m.forEach(function(e2) {
      o && e2.removeEventListener("scroll", n);
      s && e2.removeEventListener("resize", n);
    });
    p && p();
    _ && _.disconnect();
    _ = null;
    if (d) {
      cancelAnimationFrame(w);
    }
  };
}
var computePosition = function(e, t, n) {
  var r = /* @__PURE__ */ new Map();
  var i = __assign({ platform }, n);
  var o = __assign(__assign({}, i.platform), { _c: r });
  return computePosition$1(e, t, __assign(__assign({}, i), { platform: o }));
};
var alcPopupCss = ":host{display:block}alc-popup{position:relative;display:inline-block}.alc-popup__content{position:absolute;top:0px;left:0px;z-index:1060;display:none;width:-moz-max-content;width:-webkit-max-content;width:max-content}.alc-popup__content--active{display:block}.alc-popup__content--fixed{position:fixed}.alc-popup__arrow{position:absolute}";
var AlcPopup = function() {
  function e(e2) {
    registerInstance(this, e2);
    this.padding = 8;
    this.active = false;
    this.placement = "bottom";
    this.flip = false;
    this.shift = false;
    this.strategy = "absolute";
    this.distance = 0;
    this.sync = null;
    this.arrow = false;
  }
  e.prototype.watchActive = function(e2) {
    if (e2) {
      this.start();
    } else {
      if (this.cleanup) {
        this.cleanup();
      }
    }
  };
  e.prototype.componentDidLoad = function() {
    if (this.active) {
      this.start();
    }
  };
  e.prototype.disconnectedCallback = function() {
    if (this.cleanup) {
      this.cleanup();
    }
  };
  e.prototype.start = function() {
    var e2 = this;
    if (!this.anchorEl || !this.popupEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popupEl, function() {
      e2.reposition();
    });
  };
  e.prototype.reposition = function() {
    var e2 = this;
    var t = this.resolveMiddleware();
    computePosition(this.anchorEl, this.popupEl, { placement: this.placement, middleware: t, strategy: this.strategy }).then(function(t2) {
      var n;
      var r = t2.x, i = t2.y, o = t2.middlewareData, a = t2.placement;
      Object.assign(e2.popupEl.style, { left: "".concat(r, "px"), top: "".concat(i, "px") });
      var s = { top: "bottom", right: "left", bottom: "top", left: "right" }[a.split("-")[0]];
      if (o.arrow) {
        var u = o.arrow, c = u.x, f = u.y, l = u.centerOffset;
        var v = { top: 225, right: 315, bottom: 45, left: 135 };
        var d = "";
        var g = "";
        var m = Math.sign(l) * -3;
        if (a === "bottom" || a === "top") {
          g = "".concat(c + m, "px");
        } else {
          d = "".concat(f + m, "px");
        }
        Object.assign(e2.arrowEl.style, (n = { bottom: "", right: "", top: d, left: g }, n[s] = "".concat(-e2.arrowEl.offsetWidth / 2, "px"), n.transform = "rotate(".concat(v[s], "deg)"), n));
      }
    });
  };
  e.prototype.resolveMiddleware = function() {
    var e2 = this;
    var t = this.padding;
    var n = [offset({ mainAxis: this.distance })];
    if (this.flip) {
      n.push(flip({ padding: t }));
    }
    n.push(size({ apply: function(t2) {
      var n2 = t2.rects, r = t2.availableWidth, i = t2.availableHeight, o = t2.elements;
      if (e2.sync) {
        var a = e2.sync === "width" || e2.sync === "both";
        var s = e2.sync === "height" || e2.sync === "both";
        Object.assign(o.floating.style, { width: a ? "".concat(n2.reference.width, "px") : "", height: s ? "".concat(n2.reference.width, "px") : "" });
      } else {
        Object.assign(o.floating.style, { width: "", height: "" });
      }
    } }));
    if (this.shift) {
      n.push(shift({ padding: t }));
    }
    if (this.arrow) {
      n.push(arrow({ element: this.arrowEl }));
    }
    return n;
  };
  e.prototype.render = function() {
    var e2 = this;
    return h(Host, { key: "b0d9dc5b6ecaea7e890b354ad784867477c746b2" }, h("div", { key: "aad811091ef55a2ef72eed027e63ceea97a358cc", ref: function(t) {
      return e2.anchorEl = t;
    } }, h("slot", { key: "baba256e7df545e6fc6c667e03ff2344f2013db1", name: "anchor" })), h("div", { key: "ab9285834ac4eb48c8633cc6adc336589e87660e", class: { "alc-popup__content": true, "alc-popup__content--active": this.active, "alc-popup__content--fixed": this.strategy === "fixed" }, ref: function(t) {
      return e2.popupEl = t;
    } }, h("slot", { key: "a702544be7061ef03f84d75cd9cafb7e2bb933e9" }), h("div", { key: "6e1f20ded951cfacfd406820d08637e7dff76c93", ref: function(t) {
      return e2.arrowEl = t;
    }, class: this.arrow ? "alc-popup__arrow" : "" })));
  };
  Object.defineProperty(e, "watchers", { get: function() {
    return { active: ["watchActive"] };
  }, enumerable: false, configurable: true });
  return e;
}();
AlcPopup.style = alcPopupCss;
export {
  AlcPopup as alc_popup
};
