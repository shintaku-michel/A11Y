import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { l as logger } from './logger.js';
import { d as defineCustomElement$3 } from './alc-badge2.js';
import { d as defineCustomElement$2 } from './alc-icon2.js';

const alcHeaderNotificationsCss = ".alc-header-notifications .alc-badge{border-radius:8px;--tw-bg-opacity:1;background-color:rgb(252 144 109 / var(--tw-bg-opacity));padding-top:0px;padding-bottom:0px;padding-left:2px;padding-right:2px;--tw-text-opacity:1;color:rgb(0 0 0 / var(--tw-text-opacity));line-height:1em}.alc-header-notifications__aria-live{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}";

/*
  TODO: Avaliar possibilidade de "abrir" para modificar rótulo do botão
  Nessa versão, não será possível alterar o rótulo do botão.
  Há uma certa dificuldade para lidar com slot, possível html dentro do slot,
  e a extração do texto correspondente para criar os elementos audíveis.
*/
const BUTTON_LABEL = "Notificações";
const MAX_COUNTER = 99;
const AlcHeaderNotifications$1 = /*@__PURE__*/ proxyCustomElement(class AlcHeaderNotifications extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.alcClick = createEvent(this, "alc-click", 7);
        this.overflow = false;
        this.notificationsLabel = "";
        this.notificationsAudible = "";
        /**
         * Número de notificações a serem exibidas no botão.
         */
        this.notifications = 0;
        /**
         * Define o tipo de elemento a ser renderizado. Pode ser um button ou um link.
         */
        this.variant = 'button';
        /**
         * URL para a página de notificações. Usado quando a propriedade `variant` é `link`.
         * Se o `variant` for `button`, esse atributo será ignorado.
         */
        this.url = '';
    }
    watchNotifications(newValue) {
        if (Number.isNaN(newValue)) {
            logger.warn('O valor do atributo "notifications" deve ser numérico. Assumindo o valor padrão 0.');
            newValue = 0;
        }
        if (newValue === 0) {
            this.notificationsLabel = "";
            this.notificationsAudible = "";
            this.overflow = false;
        }
        else if (newValue > MAX_COUNTER) {
            this.notificationsLabel = `${MAX_COUNTER}+`;
            this.notificationsAudible = `Mais de ${MAX_COUNTER} ${BUTTON_LABEL}`;
            this.overflow = true;
        }
        else {
            this.notificationsLabel = newValue.toString();
            this.notificationsAudible = `${newValue.toString()} ${BUTTON_LABEL}`;
            this.overflow = false;
        }
    }
    async handleClick(event) {
        const { defaultPrevented } = this.alcClick.emit();
        if (defaultPrevented) {
            event.preventDefault();
        }
    }
    componentWillLoad() {
        this.watchNotifications(this.notifications);
    }
    render() {
        const commonProps = {
            class: "alc-header-button",
            "aria-label": this.overflow ? `${this.notificationsAudible}` : null,
            onClick: (event) => this.handleClick(event),
        };
        return (h(Host, { key: '759c155108643e394a594a575849491a1e421292' }, h("span", { key: 'b7c18e91416ddc03f49fa4f43a1118eeb619a8da', class: "alc-header-notifications" }, this.variant === 'button' ? (h("button", Object.assign({}, commonProps), this.renderContent())) : (h("a", Object.assign({ href: this.url }, commonProps), this.renderContent())), h("span", { key: '8f5d05866bac68b79671c9ba22246aba679e8e10', role: "status", "aria-live": "polite", "aria-atomic": "true", class: "alc-header-notifications__aria-live" }, this.notifications
            ?
                `${this.notificationsAudible}`
            :
                null))));
    }
    renderContent() {
        const badge = (h("alc-badge", { color: "warning", count: true, label: this.notificationsLabel }, h("alc-icon", { name: "bell", label: "", class: "alc-header-button__icon" })));
        const label = (h("span", { class: "alc-header-button__label" }, BUTTON_LABEL));
        return [
            badge,
            label
        ];
    }
    static get watchers() { return {
        "notifications": ["watchNotifications"]
    }; }
    static get style() { return alcHeaderNotificationsCss; }
}, [0, "alc-header-notifications", {
        "notifications": [514],
        "variant": [513],
        "url": [513]
    }, undefined, {
        "notifications": ["watchNotifications"]
    }]);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["alc-header-notifications", "alc-badge", "alc-icon"];
    components.forEach(tagName => { switch (tagName) {
        case "alc-header-notifications":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, AlcHeaderNotifications$1);
            }
            break;
        case "alc-badge":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "alc-icon":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
    } });
}

const AlcHeaderNotifications = AlcHeaderNotifications$1;
const defineCustomElement = defineCustomElement$1;

export { AlcHeaderNotifications, defineCustomElement };
//# sourceMappingURL=alc-header-notifications.js.map

//# sourceMappingURL=alc-header-notifications.js.map