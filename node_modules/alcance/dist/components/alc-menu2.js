import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';

const alcMenuCss = ".alc-menu{display:block;padding-top:0.5rem;padding-bottom:0.5rem;background-color:var(--alc-color-surface-primary)}";

const AlcMenu = /*@__PURE__*/ proxyCustomElement(class AlcMenu extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.hasFocus = false;
        this.getListItems = () => Array.from(this.hostElement.querySelectorAll('[role^=menuitem]'));
        this.includeFirstItemInTabNavigation = () => {
            this.items.forEach((item, pos) => {
                item.setAttribute('tabindex', pos === 0 ? '0' : '-1');
            });
        };
        this.removeAllItemsFromTabNavigation = () => {
            this.items.forEach(item => item.setAttribute('tabindex', '-1'));
        };
        this.setHasFocus = (hasFocus = true) => {
            this.hasFocus = hasFocus;
            if (hasFocus) {
                this.removeAllItemsFromTabNavigation();
            }
            else {
                this.includeFirstItemInTabNavigation();
            }
        };
    }
    async refresh() {
        this.items = this.getListItems();
        this.includeFirstItemInTabNavigation();
    }
    handleKeydown(event) {
        if ('ArrowDown' === event.key) {
            event.preventDefault();
            this.handleFocusedItemIndex();
            return;
        }
        if ('ArrowUp' === event.key) {
            event.preventDefault();
            this.handleFocusedItemIndex(-1);
            return;
        }
    }
    /**
     * Focar item recém-selecionado
     */
    handleAlcSelect(e) {
        const index = this.items.findIndex(item => item === e.target);
        if (index === null)
            return;
        this.handleFocusItem(index);
    }
    handleFocusin({ target }) {
        // Se já tem o foco, nada a fazer
        if (this.hasFocus) {
            return;
        }
        if (this.hostElement.contains(target)) {
            this.setHasFocus(true);
        }
    }
    handleFocusout({ relatedTarget }) {
        if (!this.hostElement.contains(relatedTarget)) {
            this.setHasFocus(false);
        }
    }
    handleFocusedItemIndex(direction = 1) {
        const currentIndex = this.items.indexOf(document.activeElement);
        if (currentIndex === -1)
            return;
        let nextIndex = currentIndex + direction;
        const itemsLength = this.items.length - 1;
        if (nextIndex > itemsLength) {
            nextIndex = 0;
        }
        if (nextIndex < 0) {
            nextIndex = itemsLength;
        }
        this.handleFocusItem(nextIndex);
    }
    handleFocusItem(index) {
        const item = this.items[index];
        if (item instanceof HTMLElement) {
            // Seta foco no atual
            item.focus();
        }
    }
    componentDidRender() {
        this.items = this.getListItems();
    }
    componentDidLoad() {
        this.includeFirstItemInTabNavigation();
    }
    render() {
        return (h(Host, { key: '2aa137629ce5187b9191d9885a0b716d51ef4861', role: "menu", class: "alc-menu" }, h("slot", { key: '6442d2320bb9c5b2f83859688fb464ac5ab903da' })));
    }
    get hostElement() { return this; }
    static get style() { return alcMenuCss; }
}, [4, "alc-menu", {
        "refresh": [64]
    }, [[0, "keydown", "handleKeydown"], [0, "alc-select", "handleAlcSelect"], [0, "focusin", "handleFocusin"], [0, "focusout", "handleFocusout"]]]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["alc-menu"];
    components.forEach(tagName => { switch (tagName) {
        case "alc-menu":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, AlcMenu);
            }
            break;
    } });
}

export { AlcMenu as A, defineCustomElement as d };
//# sourceMappingURL=alc-menu2.js.map

//# sourceMappingURL=alc-menu2.js.map