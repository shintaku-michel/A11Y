import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { g as getFocusableElements } from './keydown.js';
import { g as getUniqueId } from './getUniqueId.js';
import { l as logger } from './logger.js';
import { d as defineCustomElement$1 } from './alc-popup2.js';

const alcDropdownCss = "[data-alc-theme=\"dark\"] alc-dropdown{--border-color:var(--alc-color-neutral-80)}[data-alc-theme=\"light\"] alc-dropdown{--border-color:var(--alc-color-neutral-10)}alc-dropdown{position:relative;display:inline-block}.alc-dropdown__content{overflow:auto;background-color:var(--alc-color-surface-primary);border-radius:0.25rem;border-width:1px;border-color:var(--border-color);--tw-shadow-color:#000000;--tw-shadow:var(--tw-shadow-colored);--tw-drop-shadow:drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));-webkit-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);max-height:inherit;}.alc-dropdown__content--opened{display:block}@-webkit-keyframes Scale{0%{opacity:0;-webkit-transform:scale(0.8);transform:scale(0.8)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes Scale{0%{opacity:0;-webkit-transform:scale(0.8);transform:scale(0.8)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}";

const AlcDropdown = /*@__PURE__*/ proxyCustomElement(class AlcDropdown extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.alcShow = createEvent(this, "alc-show", 7);
        this.alcAfterShow = createEvent(this, "alc-after-show", 6);
        this.alcHide = createEvent(this, "alc-hide", 7);
        this.alcAfterHide = createEvent(this, "alc-after-hide", 6);
        this.hideOnEventsMap = new Map();
        /**
         * Indica se o dropdown esta aberto ou não. Pode-se usar essa propriedade em vez dos métodos show/hide.
         */
        this.open = false;
        /**
         * Nome do evento que, ao ocorrer no conteúdo do dropdown, vai fazer com que ele seja fechado.
         * Podem ser informados vários eventos, separados por um espaço em branco.
         */
        this.hideOn = '';
        this.handleAnchorClick = (event) => {
            var _a;
            if (!(event.target instanceof Node)) {
                return;
            }
            // Se o click foi no trigger (ou dentro dele)
            if ((_a = this.trigger) === null || _a === void 0 ? void 0 : _a.contains(event.target)) {
                this.toggleDropdown();
            }
        };
        this.toggleDropdown = async () => {
            this.open ? this.hide() : this.show();
        };
    }
    watchOpen() {
        if (this.trigger) {
            this.handleTriggerAriaExpanded();
            this.handleTriggerTabindex();
        }
    }
    watchHideOn() {
        // Remove todos os eventos anteriores
        this.hideOnEventsMap.forEach((listener, eventName) => {
            this.content.removeEventListener(eventName, listener);
            this.hideOnEventsMap.delete(eventName);
        });
        // Adiciona todos os novos eventos
        this.addHideOnListeners();
    }
    async handleKeydown(event) {
        if (!this.open)
            return;
        if (event.key !== 'Escape')
            return;
        if (event.defaultPrevented)
            return;
        event.preventDefault();
        await this.hide();
        this.handleTriggerFocus();
    }
    /**
     * Método para abrir o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente exibido com essa chamada ao método.
     */
    async show() {
        if (this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcShow.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = true;
        this.alcAfterShow.emit();
        return true;
    }
    /**
     * Método para fechar o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente oculto com essa chamada ao método.
     */
    async hide() {
        if (!this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcHide.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = false;
        this.alcAfterHide.emit();
        return true;
    }
    handleTriggerFocus() {
        var _a;
        (_a = this.trigger) === null || _a === void 0 ? void 0 : _a.focus();
    }
    handleContentFocus() {
        const contentFirstFocusable = getFocusableElements(this.content)[0];
        if (!contentFirstFocusable)
            return;
        if (contentFirstFocusable instanceof HTMLElement) {
            contentFirstFocusable.focus();
        }
    }
    setTriggerAccessibility() {
        if (this.trigger.getAttribute('role') === null) {
            this.trigger.setAttribute('role', "button");
        }
        const contentElementChild = this.content.firstElementChild;
        if (this.trigger.getAttribute('aria-haspopup') === null) {
            const ariaHaspopup = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.role) === "menu" ? "menu" : "dialog";
            this.trigger.setAttribute('aria-haspopup', ariaHaspopup);
        }
        let id = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.id) ? contentElementChild.id : getUniqueId();
        // Se não ter conteudo dentro, o id vai no alc-dropdown__content se não vai no conteudo
        if (!contentElementChild) {
            this.content.id = id;
        }
        else {
            contentElementChild.id = id;
        }
        this.trigger.setAttribute('aria-controls', id);
    }
    handleTriggerAriaExpanded() {
        this.trigger.ariaExpanded = `${this.open}`;
    }
    handleTriggerTabindex() {
        this.trigger.tabIndex = this.open ? -1 : this.originalTriggerTabindex;
    }
    async handleFocusOut(e) {
        const { relatedTarget } = e;
        const isNode = relatedTarget instanceof Node;
        /*
          OBSERVAÇÃO:
          Para que um clique qualquer dentro de content, mesmo se for um elemento não focalizável,
          não resulte em relatedTarget null, foi definido tabindex=-1 para o content.
          Se não fosse assim, um clique em um elemento não focalizável dentro de content
          resultaria no fechamento indesejado do dropdown.
        */
        if (isNode && this.el.contains(relatedTarget)) {
            return;
        }
        await this.hide();
    }
    handleCloseOn(e) {
        if (e.defaultPrevented) {
            return;
        }
        this.open = false;
    }
    addHideOnListeners() {
        const hideOn = this.hideOn.trim();
        // Nada a fazer se for um string vazia.
        if (!hideOn) {
            return;
        }
        const eventNames = hideOn.split(/\s+/);
        eventNames.forEach(eventName => {
            const listener = (e) => this.handleCloseOn(e);
            this.hideOnEventsMap.set(eventName, listener);
            this.content.addEventListener(eventName, listener);
        });
    }
    componentDidUpdate() {
        if (this.open) {
            // Quando o trigger for acionado por teclado para abrir o foco deve ir para o primeiro elemento focalizável dentro do conteúdo
            // Foi adicionado para tratar no componentDidUpdate pois no handleKeydown o dropdown ainda esta fechado, logo o 'elemento.focus()' não funciona
            // Aqui o componente ja foi renderizado com o novo estado.
            this.handleContentFocus();
        }
    }
    getTrigger() {
        let slot = null;
        let trigger = null;
        slot = this.el.querySelector('[slot="trigger"]');
        if (slot) {
            if (slot.tagName === 'BUTTON' || slot.getAttribute('role') === 'button') {
                // Trigger é o próprio slot se ele mesmo for o botão
                trigger = slot;
            }
            else {
                // Trigger é o primeiro botão encontrado dentro do slot (se existir)
                trigger = slot.querySelector('button, [role="button"]');
            }
        }
        if (trigger === null) {
            logger.warn(this.el, 'alc-dropdown não localizou um trigger válido. Slot deve ser ou conter um botão. Veja a documentação para mais detalhes.');
        }
        return trigger;
    }
    componentDidLoad() {
        this.trigger = this.getTrigger();
        if (this.trigger) {
            this.setTriggerAccessibility();
            this.handleTriggerAriaExpanded();
            this.originalTriggerTabindex = this.trigger.tabIndex;
        }
        // Adiciona close-on listeners
        this.addHideOnListeners();
    }
    render() {
        return (h(Host, { key: '2a3cb9758c23c1f7f895322bffa6893a4680e1e8' }, h("alc-popup", { key: '0c352d9d09c09df64e50c0561633120705875ef1', active: this.open, placement: "bottom-start", flip: true, shift: true, strategy: "fixed", onFocusout: this.handleFocusOut.bind(this), distance: 2 }, h("div", { key: '6b60a206a5a326e53c1f3afed07b0e53b52c9832', slot: "anchor", onClick: this.handleAnchorClick }, h("slot", { key: '528d7a27ebf5bdc884d89796d3aec84ae19e18e5', name: "trigger" })), h("div", { key: '2407874043bb9e9cabfaf9bc13751040f15f0c18', class: "alc-dropdown__content", ref: (el) => this.content = el, tabindex: '-1' }, h("slot", { key: 'ecd68a468c536a351baa3c5eb75fad9fbd88c2b4' })))));
    }
    get el() { return this; }
    static get watchers() { return {
        "open": ["watchOpen"],
        "hideOn": ["watchHideOn"]
    }; }
    static get style() { return alcDropdownCss; }
}, [4, "alc-dropdown", {
        "open": [1540],
        "hideOn": [513, "hide-on"],
        "show": [64],
        "hide": [64]
    }, [[0, "keydown", "handleKeydown"]], {
        "open": ["watchOpen"],
        "hideOn": ["watchHideOn"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["alc-dropdown", "alc-popup"];
    components.forEach(tagName => { switch (tagName) {
        case "alc-dropdown":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, AlcDropdown);
            }
            break;
        case "alc-popup":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}

export { AlcDropdown as A, defineCustomElement as d };
//# sourceMappingURL=alc-dropdown2.js.map

//# sourceMappingURL=alc-dropdown2.js.map