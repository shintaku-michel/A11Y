'use strict';

var index = require('./index-BOXTLnv4.js');
var logger = require('./logger-D5AeZhi-.js');

const alcTabsBaseCss = "alc-tabs{display:block}.alc-tabs{border-width:1px;border-style:solid}.alc-tabs__tab-list{border-width:0px;border-bottom-width:1px;border-style:dotted}";

const themeAlcTabsCss = "alc-tabs{--bg-color:var(--alc-color-surface);--border-color:var(--alc-color-border);--border-width:var(--alc-border-width)}[data-alc-theme=\"light\"] alc-tabs{--outline-color:var(--alc-color-action-60)}[data-alc-theme=\"dark\"] alc-tabs{--outline-color:var(--alc-color-action-30)}";

const AlcTabs = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.alcChange = index.createEvent(this, "alc-change", 7);
        this.selectedTabButton = null;
        this.tabList = null;
        this.selectedTab = null;
        this.hasScroll = false;
        this.onTabClicked = (e) => {
            this.select(e.detail.tab);
        };
    }
    selectedChange(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.select(newValue);
        }
    }
    /**
     * Seleciona uma tab pelo valor de sua propriedade `tab` ou pela referência do elemento.
     *
     * @param tab A tab a ser selecionada. Se passada como string, deve ser o valor da propriedade `tab` da tab.
     */
    async select(tab) {
        const selectedTab = getTab(this.tabs, tab);
        if (!this.shouldSwitch(selectedTab)) {
            return false;
        }
        const selectedTabButton = getTabButton(this.tabButtons, selectedTab.getAttribute('tab'));
        this.tabSwitch(selectedTab, selectedTabButton);
        this.selected = selectedTab.getAttribute('tab');
        return true;
    }
    tabSwitch(selectedTab, selectedTabButton) {
        const leavingTab = this.selectedTab;
        const leavingTabButton = this.selectedTabButton;
        this.selectedTab = selectedTab;
        this.selectedTabButton = selectedTabButton;
        selectedTab.selected = true;
        selectedTabButton.selected = true;
        if (leavingTab !== selectedTab) {
            if (leavingTab) {
                leavingTab.selected = false;
                this.alcChange.emit({ tab: selectedTab.tab });
            }
            if (leavingTabButton) {
                leavingTabButton.selected = false;
            }
        }
    }
    // Evento disparado por alc-tab-button
    selectedHandler(e) {
        this.select(e.detail.tab);
    }
    selectedNextButton(e) {
        this.onTabButtonNext(e);
    }
    selectedPreviousButton(e) {
        this.onTabButtonPrevious(e);
    }
    selectedFirstButton(e) {
        this.onTabButtonFirst(e);
    }
    selectedLastButton(e) {
        this.onTabButtonLast(e);
    }
    shouldSwitch(selectedTab) {
        const leavingTab = this.selectedTab;
        return selectedTab !== undefined && selectedTab !== leavingTab;
    }
    get tabs() {
        let tabs = Array.from(this.el.querySelectorAll('alc-tab'));
        tabs = tabs.filter(t => t.closest('alc-tabs') === this.el);
        logger.logger.log('my tabs are', tabs, this.el);
        return tabs;
    }
    get tabButtons() {
        let tabButtons = Array.from(this.el.querySelectorAll('alc-tab-button'));
        tabButtons = tabButtons.filter(b => b.closest('alc-tabs') === this.el);
        return tabButtons;
    }
    getNextButton(button) {
        let nextIndex;
        const buttonIndex = this.tabButtons.findIndex(b => b === button);
        // Último -> primeiro
        if (buttonIndex === this.tabButtons.length - 1) {
            nextIndex = 0;
        }
        else {
            nextIndex = buttonIndex + 1;
        }
        return this.tabButtons[nextIndex];
    }
    getPreviousButton(button) {
        let previousIndex;
        const buttonIndex = this.tabButtons.findIndex(b => b === button);
        // Primeiro -> último
        if (buttonIndex <= 0) {
            previousIndex = this.tabButtons.length - 1;
        }
        else {
            previousIndex = buttonIndex - 1;
        }
        return this.tabButtons[previousIndex];
    }
    handleScroll() {
        let scrollWidth = 0;
        let width = this.tabList.offsetWidth;
        let overflowX = this.tabList.style.overflowX;
        this.tabList.style.overflowX = 'auto';
        scrollWidth = this.tabList.scrollWidth;
        this.tabList.style.overflowX = overflowX;
        logger.logger.log('width', width, scrollWidth);
        this.hasScroll = scrollWidth > width;
    }
    themeLoadedHandler() {
        this.handleScroll();
    }
    async componentDidLoad() {
        var _a;
        // Se selected não tiver sido indicado, a primeira será a inicial
        const initialTab = this.selected || ((_a = this.tabs[0]) === null || _a === void 0 ? void 0 : _a.tab);
        await this.select(initialTab);
        let slotButton = Array.from(this.el.querySelectorAll('[slot="button"]'));
        this.hasButtonSlot = slotButton.some(s => s.closest('alc-tabs') === this.el);
    }
    async onTabButtonNext(e) {
        if (!this.isValidTabButton(e))
            return;
        const target = e.target;
        const nextButton = this.getNextButton(target);
        this.handleSelectTabButton(nextButton);
    }
    async onTabButtonPrevious(e) {
        if (!this.isValidTabButton(e))
            return;
        const target = e.target;
        const previousButton = this.getPreviousButton(target);
        this.handleSelectTabButton(previousButton);
    }
    async onTabButtonFirst(e) {
        if (!this.isValidTabButton(e))
            return;
        const firstButton = this.tabButtons[0];
        this.handleSelectTabButton(firstButton);
    }
    async onTabButtonLast(e) {
        if (!this.isValidTabButton(e))
            return;
        const lastButton = this.tabButtons[this.tabButtons.length - 1];
        this.handleSelectTabButton(lastButton);
    }
    async handleSelectTabButton(tab) {
        const changed = await this.select(tab.tab);
        if (changed) {
            tab.querySelector('button').focus();
        }
    }
    isValidTabButton(e) {
        const target = e.target;
        return Array.from(this.tabButtons).includes(target);
    }
    componentDidRender() {
        var _a;
        /*
         O trecho abaixo permite que o componente seja atualizado
         sempre que houver mudanças no conteúdo (como a inclusão de "fihos").
         Isso foi feito para permitir, por exemplo, que uma tab seja
         adicionada pela simples manipulação do DOM.
         */
        (_a = this.mo) === null || _a === void 0 ? void 0 : _a.disconnect();
        this.mo = new MutationObserver(() => {
            index.forceUpdate(this.el);
        });
        this.mo.observe(this.el, { childList: true });
        this.mo.observe(this.el.querySelector('.alc-tabs'), { childList: true });
        this.tabs.map((tab, i) => {
            const tabpanel = tab.querySelector('[role="tabpanel"]');
            if (this.tabButtons.length <= i) {
                return;
            }
            const button = this.tabButtons[i].querySelector('button');
            if (!tabpanel.hasAttribute('id')) {
                tabpanel.setAttribute('id', `tab_${i}`);
            }
            if (!button.hasAttribute('id')) {
                button.setAttribute('id', `button_${i}`);
            }
            tabpanel.setAttribute('aria-labelledby', button.getAttribute('id'));
            button.setAttribute('aria-controls', tabpanel.getAttribute('id'));
        });
        // this.handleScroll();
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mo) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        let tabList;
        if (!this.hasButtonSlot) {
            tabList = this.tabs.map((tab) => {
                // Não parece ser um boa ideia criar esses elementos dinamicamente, dessa forma
                // Fazendo assim, a inclusão de uma nova tab no DOM, por exemplo, não
                // reflete automaticamente aqui, porque não ocorre o "render".
                return (index.h("alc-tab-button", { tab: tab.tab }, tab.label));
            });
        }
        logger.logger.log('rendering', this.el, tabList);
        return (index.h(index.Host, { onAlcTabButtonClick: this.onTabClicked, onAlcTabButtonNext: this.onTabButtonNext.bind(this), onAlcTabButtonPrevious: this.onTabButtonPrevious.bind(this) }, index.h("div", { class: "alc-tabs" }, index.h("alc-scroll-panel", { hasFocus: false, scrollToElement: this.selectedTabButton }, index.h("div", { role: "tablist", ref: el => this.tabList = el, class: "alc-tabs__tab-list" }, index.h("slot", { name: "button" }), tabList)), index.h("slot", null))));
    }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "selected": ["selectedChange"]
    }; }
};
const getTab = (tabs, tab) => {
    const tabEl = (typeof tab === 'string')
        ? tabs.find(t => t.tab === tab)
        : tab;
    if (!tabEl) {
        logger.logger.error(`tab with id: "${tabEl}" does not exist`);
    }
    return tabEl;
};
const getTabButton = (buttons, tab) => {
    const buttonEl = buttons.find(b => b.tab === tab);
    if (!buttonEl) {
        logger.logger.error(`tab button with id: "${buttonEl}" does not exist`);
    }
    return buttonEl;
};
AlcTabs.style = {
    base: alcTabsBaseCss,
    theme: themeAlcTabsCss
};

exports.alc_tabs = AlcTabs;
//# sourceMappingURL=alc-tabs.entry.cjs.js.map

//# sourceMappingURL=alc-tabs.cjs.entry.js.map