'use strict';

var index = require('./index-BOXTLnv4.js');
var logger = require('./logger-D5AeZhi-.js');

let CACHED_MAP;
const getIconMap = () => {
    if (typeof window === 'undefined') {
        return new Map();
    }
    else {
        if (!CACHED_MAP) {
            const win = window;
            win.Ionicons = win.Ionicons || {};
            CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();
        }
        return CACHED_MAP;
    }
};
const getUrl = (i) => {
    let url = getSrc(i.src);
    if (url) {
        return url;
    }
    url = getName(i.name, i.icon);
    if (url) {
        return getNamedUrl(url);
    }
    if (i.icon) {
        url = getSrc(i.icon);
        if (url) {
            return url;
        }
        url = getSrc(i.icon);
        if (url) {
            return url;
        }
    }
    return null;
};
const getNamedUrl = (iconName) => {
    const url = getIconMap().get(iconName);
    if (url) {
        return url;
    }
    return index.getAssetPath(`assets/icons/${iconName}.svg`);
};
const getName = (iconName, icon) => {
    // if an icon was passed in using the ios or md attributes
    // set the iconName to whatever was passed in
    if (!iconName && icon && !isSrc(icon)) {
        iconName = icon;
    }
    if (isStr(iconName)) {
        iconName = toLower(iconName);
    }
    if (!isStr(iconName) || iconName.trim() === '') {
        return null;
    }
    // only allow alpha characters and dash
    const invalidChars = iconName.replace(/[a-z]|-|\d/gi, '');
    if (invalidChars !== '') {
        return null;
    }
    return iconName;
};
const getSrc = (src) => {
    if (isStr(src)) {
        src = src.trim();
        if (isSrc(src)) {
            return src;
        }
    }
    return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === 'string';
const toLower = (val) => val.toLowerCase();
/**
 * Elements inside of web components sometimes need to inherit global attributes
 * set on the host. For example, the inner input in `ion-input` should inherit
 * the `title` attribute that developers set directly on `ion-input`. This
 * helper function should be called in componentWillLoad and assigned to a variable
 * that is later used in the render function.
 *
 * This does not need to be reactive as changing attributes on the host element
 * does not trigger a re-render.
 */
const inheritAttributes = (el, attributes = []) => {
    const attributeObject = {};
    attributes.forEach(attr => {
        if (el.hasAttribute(attr)) {
            const value = el.getAttribute(attr);
            if (value !== null) {
                attributeObject[attr] = el.getAttribute(attr);
            }
            el.removeAttribute(attr);
        }
    });
    return attributeObject;
};

const validateContent = (svgContent) => {
    const div = document.createElement('div');
    div.innerHTML = svgContent;
    // setup this way to ensure it works on our buddy IE
    for (let i = div.childNodes.length - 1; i >= 0; i--) {
        if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {
            div.removeChild(div.childNodes[i]);
        }
    }
    // must only have 1 root element
    const svgElm = div.firstElementChild;
    if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {
        const svgClass = svgElm.getAttribute('class') || '';
        svgElm.setAttribute('class', (svgClass + ' alc-icon__image').trim());
        // root element must be an svg
        // lets double check we've got valid elements
        // do not allow scripts
        if (isValid(svgElm)) {
            return div.innerHTML;
        }
    }
    return '';
};
const isValid = (elm) => {
    if (elm.nodeType === 1) {
        if (elm.nodeName.toLowerCase() === 'script') {
            return false;
        }
        for (let i = 0; i < elm.attributes.length; i++) {
            const val = elm.attributes[i].nodeName;
            if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {
                return false;
            }
        }
        for (let i = 0; i < elm.childNodes.length; i++) {
            if (!isValid(elm.childNodes[i])) {
                return false;
            }
        }
    }
    return true;
};

const alciconContent = new Map();
const requests = new Map();
/*
 * Originalmente, a função validateContent (importada acima) inseria uma classe
 * no elemento svg obtido. Precisávamos de outra classe (do Alcance, não o ionic),
 * e que essa classe fosse inserida sempre, independentemente de validação.
 * Por isso foi criada essa função aqui. Desse modo, o svg obtido já fica com
 * a classe devida antes de ir para o cache.
 *
 * Obs.: A inclusão da classe dentro da função de validação (como feito originalmente
 * pela equipe do ionic) parece ser um desvio do objetivo da função.
 */
const addSvgClass = (svgContent, className) => {
    // Cria container temporário para o svg
    const div = document.createElement('div');
    div.innerHTML = svgContent;
    // Adiciona a classe necessária no svg
    div.querySelector('svg').classList.add(className);
    // Atualiza string HTML do svg.
    return div.innerHTML;
};
const getSvgContent = (url, sanitize) => {
    // see if we already have a request for this url
    let req = requests.get(url);
    if (!req) {
        if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {
            // we don't already have a request
            req = fetch(url).then((rsp) => {
                if (rsp.ok) {
                    return rsp.text().then((svgContent) => {
                        if (svgContent && sanitize !== false) {
                            svgContent = validateContent(svgContent);
                        }
                        if (svgContent) {
                            svgContent = addSvgClass(svgContent, 'alc-icon__image');
                        }
                        alciconContent.set(url, svgContent || '');
                    });
                }
                alciconContent.set(url, '');
            });
            // cache for the same requests
            requests.set(url, req);
        }
        else {
            // set to empty for ssr scenarios and resolve promise
            alciconContent.set(url, '');
            return Promise.resolve();
        }
    }
    return req;
};

const alcIconCss = "alc-icon{display:inline-block}.icon-inner{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center}alc-icon.size-x-small{font-size:0.75rem;line-height:1rem}alc-icon.size-small{font-size:0.875rem;line-height:1rem}alc-icon.size-medium{font-size:1rem;line-height:1.5rem}alc-icon.size-large{font-size:1.125rem;line-height:1.5rem}alc-icon.size-x-large{font-size:1.25rem;line-height:1.5rem}alc-icon.size-xx-large{font-size:1.375rem;line-height:2rem}.alc-icon__image{position:relative;top:0.125em;margin-top:-0.125em;height:1em;width:1em}";

const AlcIcon = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.iconName = null;
        this.inheritedAttributes = {};
        this.role = 'img';
        this.isVisible = false;
        /**
         * Define se o ícone deve ser espelhado horizontalmente quando `dir` for `"rtl"`.
         */
        this.flipRtl = false;
        /**
         * Se ativado, a carga do ícone ocorrerá somente quando o componente estiver visível na _viewport_.
         */
        this.lazy = false;
        /**
         * Quando definido como `true`, o conteúdo SVG obtido via HTTP passará por uma limpeza.
         * Conteúdo que contenha algum elemento `<script>` ou atributo que comece com `on`, como `onclick`, será descartado.
         * Sendo descartado, a imagem não será mostrada.
         * @default false
         */
        this.sanitize = false;
        this.hasAriaHidden = () => {
            const { el } = this;
            return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';
        };
    }
    componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
    }
    connectedCallback() {
        // purposely do not return the promise here because loading
        // the svg file should not hold up loading the app
        // only load the svg if it's visible
        this.waitUntilVisible(this.el, '50px', () => {
            this.isVisible = true;
            this.loadIcon();
        });
    }
    disconnectedCallback() {
        if (this.io) {
            this.io.disconnect();
            this.io = undefined;
        }
    }
    waitUntilVisible(el, rootMargin, cb) {
        if (this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {
            const io = (this.io = new window.IntersectionObserver((data) => {
                if (data[0].isIntersecting) {
                    io.disconnect();
                    this.io = undefined;
                    cb();
                }
            }, { rootMargin }));
            io.observe(el);
        }
        else {
            // browser doesn't support IntersectionObserver
            // so just fallback to always show it
            cb();
        }
    }
    loadIcon() {
        if (this.isVisible) {
            const url = getUrl(this);
            if (url) {
                if (alciconContent.has(url)) {
                    // sync if it's already loaded
                    this.svgContent = alciconContent.get(url);
                    logger.logger.log(this.svgContent);
                }
                else {
                    // async if it hasn't been loaded
                    getSvgContent(url, this.sanitize).then(() => (this.svgContent = alciconContent.get(url)));
                }
            }
        }
        // Se label estiver preenchido
        if (this.label) {
            this.ariaLabel = this.label;
            this.role = 'img';
        }
        // Se label for um string vazio
        else if (this.label === '') {
            this.ariaLabel = undefined;
            this.role = 'presentation';
        }
    }
    render() {
        var _a;
        (_a = this.label) !== null && _a !== void 0 ? _a : logger.logger.report('label', this.el.tagName.toLowerCase(), this.el);
        const { label, iconName, ariaLabel, inheritedAttributes, role } = this;
        const flipRtl = this.flipRtl ||
            (iconName &&
                (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&
                this.flipRtl !== false);
        /**
         * Only set the aria-label if a) we have generated
         * one for the icon and if aria-hidden is not set to "true".
         * If developer wants to set their own aria-label, then
         * inheritedAttributes down below will override whatever
         * default label we have set.
         */
        return (index.h(index.Host, Object.assign({ key: 'd9c68737d9c24cc00a11fb0f95d44529b2093f1e', label: label, "aria-label": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: role, class: {
                'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl',
            } }, inheritedAttributes), this.svgContent ? (index.h("span", { class: "icon-inner", innerHTML: this.svgContent })) : (index.h("span", { class: "icon-inner" }, label))));
    }
    static get assetsDirs() { return ["assets/icons"]; }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "label": ["loadIcon"],
        "name": ["loadIcon"],
        "src": ["loadIcon"],
        "icon": ["loadIcon"]
    }; }
};
AlcIcon.style = alcIconCss;

exports.alc_icon = AlcIcon;
//# sourceMappingURL=alc-icon.entry.cjs.js.map

//# sourceMappingURL=alc-icon.cjs.entry.js.map