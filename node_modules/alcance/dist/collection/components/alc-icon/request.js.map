{"version":3,"file":"request.js","sourceRoot":"","sources":["../../../../src/components/alc-icon/request.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAE7C,MAAM,CAAC,MAAM,cAAc,GAAG,IAAI,GAAG,EAAkB,CAAC;AACxD,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAwB,CAAC;AAEjD;;;;;;;;;GASG;AACH,MAAM,WAAW,GAAG,CAAC,UAAkB,EAAE,SAAiB,EAAU,EAAE;IACpE,uCAAuC;IACvC,MAAM,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IAC1C,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC;IAC3B,sCAAsC;IACtC,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAClD,+BAA+B;IAC/B,OAAO,GAAG,CAAC,SAAS,CAAC;AACvB,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,GAAW,EAAE,QAAiB,EAAE,EAAE;IAC9D,gDAAgD;IAChD,IAAI,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAE5B,IAAI,CAAC,GAAG,EAAE,CAAC;QACT,IAAI,OAAO,KAAK,KAAK,WAAW,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;YACpE,kCAAkC;YAClC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE;gBAC5B,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC;oBACX,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE;wBACpC,IAAI,UAAU,IAAI,QAAQ,KAAK,KAAK,EAAE,CAAC;4BACrC,UAAU,GAAG,eAAe,CAAC,UAAU,CAAC,CAAC;wBAC3C,CAAC;wBACD,IAAI,UAAU,EAAE,CAAC;4BACf,UAAU,GAAG,WAAW,CAAC,UAAU,EAAE,iBAAiB,CAAC,CAAC;wBAC1D,CAAC;wBACD,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,IAAI,EAAE,CAAC,CAAC;oBAC5C,CAAC,CAAC,CAAC;gBACL,CAAC;gBACD,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YAEH,8BAA8B;YAC9B,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QACzB,CAAC;aAAM,CAAC;YACN,qDAAqD;YACrD,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;YAC5B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;IACH,CAAC;IAED,OAAO,GAAG,CAAC;AACb,CAAC,CAAC","sourcesContent":["import { validateContent } from './validate';\n\nexport const alciconContent = new Map<string, string>();\nconst requests = new Map<string, Promise<any>>();\n\n/*\n * Originalmente, a função validateContent (importada acima) inseria uma classe\n * no elemento svg obtido. Precisávamos de outra classe (do Alcance, não o ionic),\n * e que essa classe fosse inserida sempre, independentemente de validação.\n * Por isso foi criada essa função aqui. Desse modo, o svg obtido já fica com\n * a classe devida antes de ir para o cache.\n *\n * Obs.: A inclusão da classe dentro da função de validação (como feito originalmente\n * pela equipe do ionic) parece ser um desvio do objetivo da função.\n */\nconst addSvgClass = (svgContent: string, className: string): string => {\n  // Cria container temporário para o svg\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // Adiciona a classe necessária no svg\n  div.querySelector('svg').classList.add(className);\n  // Atualiza string HTML do svg.\n  return div.innerHTML;\n}\n\nexport const getSvgContent = (url: string, sanitize: boolean) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            if (svgContent) {\n              svgContent = addSvgClass(svgContent, 'alc-icon__image');\n            }\n            alciconContent.set(url, svgContent || '');\n          });\n        }\n        alciconContent.set(url, '');\n      });\n\n      // cache for the same requests\n      requests.set(url, req);\n    } else {\n      // set to empty for ssr scenarios and resolve promise\n      alciconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n\n  return req;\n};"]}