import { Build, Host, h } from "@stencil/core";
import logger from "../utils/logger";
import { getSvgContent, alciconContent } from "./request";
import { /* getName , */ getUrl, inheritAttributes } from "./utils";
export class AlcIcon {
    constructor() {
        this.iconName = null;
        this.inheritedAttributes = {};
        this.role = 'img';
        this.isVisible = false;
        /**
         * Define se o ícone deve ser espelhado horizontalmente quando `dir` for `"rtl"`.
         */
        this.flipRtl = false;
        /**
         * Se ativado, a carga do ícone ocorrerá somente quando o componente estiver visível na _viewport_.
         */
        this.lazy = false;
        /**
         * Quando definido como `true`, o conteúdo SVG obtido via HTTP passará por uma limpeza.
         * Conteúdo que contenha algum elemento `<script>` ou atributo que comece com `on`, como `onclick`, será descartado.
         * Sendo descartado, a imagem não será mostrada.
         * @default false
         */
        this.sanitize = false;
        this.hasAriaHidden = () => {
            const { el } = this;
            return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';
        };
    }
    componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
    }
    connectedCallback() {
        // purposely do not return the promise here because loading
        // the svg file should not hold up loading the app
        // only load the svg if it's visible
        this.waitUntilVisible(this.el, '50px', () => {
            this.isVisible = true;
            this.loadIcon();
        });
    }
    disconnectedCallback() {
        if (this.io) {
            this.io.disconnect();
            this.io = undefined;
        }
    }
    waitUntilVisible(el, rootMargin, cb) {
        if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {
            const io = (this.io = new window.IntersectionObserver((data) => {
                if (data[0].isIntersecting) {
                    io.disconnect();
                    this.io = undefined;
                    cb();
                }
            }, { rootMargin }));
            io.observe(el);
        }
        else {
            // browser doesn't support IntersectionObserver
            // so just fallback to always show it
            cb();
        }
    }
    loadIcon() {
        if (Build.isBrowser && this.isVisible) {
            const url = getUrl(this);
            if (url) {
                if (alciconContent.has(url)) {
                    // sync if it's already loaded
                    this.svgContent = alciconContent.get(url);
                    logger.log(this.svgContent);
                }
                else {
                    // async if it hasn't been loaded
                    getSvgContent(url, this.sanitize).then(() => (this.svgContent = alciconContent.get(url)));
                }
            }
        }
        // Se label estiver preenchido
        if (this.label) {
            this.ariaLabel = this.label;
            this.role = 'img';
        }
        // Se label for um string vazio
        else if (this.label === '') {
            this.ariaLabel = undefined;
            this.role = 'presentation';
        }
    }
    render() {
        var _a;
        (_a = this.label) !== null && _a !== void 0 ? _a : logger.report('label', this.el.tagName.toLowerCase(), this.el);
        const { label, iconName, ariaLabel, inheritedAttributes, role } = this;
        const flipRtl = this.flipRtl ||
            (iconName &&
                (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&
                this.flipRtl !== false);
        /**
         * Only set the aria-label if a) we have generated
         * one for the icon and if aria-hidden is not set to "true".
         * If developer wants to set their own aria-label, then
         * inheritedAttributes down below will override whatever
         * default label we have set.
         */
        return (h(Host, Object.assign({ key: 'd9c68737d9c24cc00a11fb0f95d44529b2093f1e', label: label, "aria-label": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: role, class: {
                'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl',
            } }, inheritedAttributes), Build.isBrowser && this.svgContent ? (h("span", { class: "icon-inner", innerHTML: this.svgContent })) : (h("span", { class: "icon-inner" }, label))));
    }
    static get is() { return "alc-icon"; }
    static get originalStyleUrls() {
        return {
            "$": ["alc-icon.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["alc-icon.css"]
        };
    }
    static get assetsDirs() { return ["assets/icons"]; }
    static get properties() {
        return {
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Equivalente textual do \u00EDcone. Seu uso \u00E9 semelhante ao atributo `alt` de uma imagem.\nEsse texto ser\u00E1 lido por software leitor de tela, e utilizado no lugar do \u00EDcone se por qualquer motivo a imagem n\u00E3o puder ser carregada no navegador."
                },
                "getter": false,
                "setter": false,
                "attribute": "label",
                "reflect": true
            },
            "flipRtl": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Define se o \u00EDcone deve ser espelhado horizontalmente quando `dir` for `\"rtl\"`."
                },
                "getter": false,
                "setter": false,
                "attribute": "flip-rtl",
                "reflect": true,
                "defaultValue": "false"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Nome do \u00EDcone que ser\u00E1 mostrado. Deve ser um dos nomes de \u00EDcone da biblioteca."
                },
                "getter": false,
                "setter": false,
                "attribute": "name",
                "reflect": true
            },
            "src": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Especifica o `src` de um arquivo SVG a ser usado como \u00EDcone."
                },
                "getter": false,
                "setter": false,
                "attribute": "src",
                "reflect": true
            },
            "icon": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Uma combina\u00E7\u00E3o de `name` e `src`.\nSe o valor for entendido como a URL de um `src`, ele definir\u00E1 a propriedade `src`.\nCaso contr\u00E1rio, assume-se como o nome de \u00EDcone da biblioteca, e define a propriedade `name`."
                },
                "getter": false,
                "setter": false,
                "attribute": "icon",
                "reflect": true
            },
            "lazy": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Se ativado, a carga do \u00EDcone ocorrer\u00E1 somente quando o componente estiver vis\u00EDvel na _viewport_."
                },
                "getter": false,
                "setter": false,
                "attribute": "lazy",
                "reflect": true,
                "defaultValue": "false"
            },
            "sanitize": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "default",
                            "text": "false"
                        }],
                    "text": "Quando definido como `true`, o conte\u00FAdo SVG obtido via HTTP passar\u00E1 por uma limpeza.\nConte\u00FAdo que contenha algum elemento `<script>` ou atributo que comece com `on`, como `onclick`, ser\u00E1 descartado.\nSendo descartado, a imagem n\u00E3o ser\u00E1 mostrada."
                },
                "getter": false,
                "setter": false,
                "attribute": "sanitize",
                "reflect": true,
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "svgContent": {},
            "isVisible": {},
            "ariaLabel": {}
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "label",
                "methodName": "loadIcon"
            }, {
                "propName": "name",
                "methodName": "loadIcon"
            }, {
                "propName": "src",
                "methodName": "loadIcon"
            }, {
                "propName": "icon",
                "methodName": "loadIcon"
            }];
    }
}
//# sourceMappingURL=alc-icon.js.map
