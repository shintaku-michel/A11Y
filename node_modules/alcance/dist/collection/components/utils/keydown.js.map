{"version":3,"file":"keydown.js","sourceRoot":"","sources":["../../../../src/components/utils/keydown.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,OAAoB,EAAE,EAAE;IACzD,MAAM,iBAAiB,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;IAC3D,qCAAqC;IACrC,kGAAkG;IAClG,OAAO,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;QACtC,MAAM,EAAE,GAAG,OAAsB,CAAC;QAClC,OAAO,EAAE,CAAC,YAAY,KAAK,IAAI,IAAI,CAAC,CAAC,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1H,CAAC,CAAC,CAAC;AACP,CAAC,CAAA;AAED,kFAAkF;AAClF,4HAA4H;AAC5H,8GAA8G;AAC9G,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,OAAoB,EAAE,EAAE;IAC5D,MAAM,iBAAiB,GAAG,OAAO,CAAC,gBAAgB,CAC9C,uGAAuG,CAC1G,CAAC;IAEF,+BAA+B;IAC/B,OAAO,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;AACzC,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,iBAA4B,EAAE,EAAE;IAC9D,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC/B,MAAM,YAAY,GAAG,iBAAiB,CAAC,CAAC,CAAgB,CAAC;QACzD,YAAY,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;AACL,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,KAAoB,EAAE,iBAA4B,EAAE,EAAE;IAChF,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC/B,MAAM,YAAY,GAAG,iBAAiB,CAAC,CAAC,CAAgB,CAAC;QACzD,MAAM,WAAW,GAAG,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAgB,CAAC;QAEnF,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,YAAY,CAAC,KAAK,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,cAAc,EAAE,CAAC;QAClC,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,QAAQ,CAAC,aAAa,KAAK,WAAW,EAAE,CAAC;YAC5D,YAAY,CAAC,KAAK,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,cAAc,EAAE,CAAC;QAClC,CAAC;QAED,IAAI,KAAK,CAAC,QAAQ,IAAI,QAAQ,CAAC,aAAa,KAAK,YAAY,EAAE,CAAC;YAC5D,WAAW,CAAC,KAAK,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC,cAAc,EAAE,CAAC;QAClC,CAAC;IAEL,CAAC;AACL,CAAC,CAAA","sourcesContent":["export const getFocusableElements = (element: HTMLElement) => {\n    const focusableElements = getAllFocusableElements(element);\n    // Retorna somente elementos visíveis\n    // Valida se o elemento possui tabindex de qualquer valor negativo e adiciona à lista de filtrados\n    return focusableElements.filter(element => {\n        const el = element as HTMLElement;\n        return el.offsetParent !== null && !(el.hasAttribute('tabindex') && parseInt(el.getAttribute('tabindex') || '0') < 0);\n    });\n}\n\n// Pega todos os elementos focaveis, inclusive invisíveis e com tabindex negativo \n// Pegar elementos invisíveis são úteis quando estão dentro de componentes que não foram renderizados, como a modal fechada.\n// E tabindex negativo é usado para controlar o foco manualmente e, para isso, queremos pegar esses elementos.\nexport const getAllFocusableElements = (element: HTMLElement) => {\n    const focusableElements = element.querySelectorAll(\n        'button, [href], input, select, textarea, [tabindex], [contenteditable]:not([contenteditable=\"false\"])',\n    );\n\n    // Converte NodeList para Array\n    return Array.from(focusableElements);\n}\n\nexport const focusFirstElement = (focusableElements: Element[]) => {\n    if (focusableElements.length > 0) {\n        const firstElement = focusableElements[0] as HTMLElement;\n        firstElement.focus();\n    }\n}\n\nexport const handleKeyDown = (event: KeyboardEvent, focusableElements: Element[]) => {\n    if (focusableElements.length > 0) {\n        const firstElement = focusableElements[0] as HTMLElement;\n        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n\n        if (focusableElements.length === 1) {\n            firstElement.focus();\n            return event.preventDefault();\n        }\n\n        if (!event.shiftKey && document.activeElement === lastElement) {\n            firstElement.focus();\n            return event.preventDefault();\n        }\n\n        if (event.shiftKey && document.activeElement === firstElement) {\n            lastElement.focus();\n            return event.preventDefault();\n        }\n\n    }\n}\n"]}