import { h, Host } from "@stencil/core";
import { getFocusableElements } from "../utils/keydown";
import { getUniqueId } from "../utils/getUniqueId";
import logger from "../utils/logger";
/**
 * @slot - O conteúdo do dropdown.
 * @slot trigger - O disparador do dropdown, usualmente um botão.
 */
export class AlcDropdown {
    constructor() {
        this.hideOnEventsMap = new Map();
        /**
         * Indica se o dropdown esta aberto ou não. Pode-se usar essa propriedade em vez dos métodos show/hide.
         */
        this.open = false;
        /**
         * Nome do evento que, ao ocorrer no conteúdo do dropdown, vai fazer com que ele seja fechado.
         * Podem ser informados vários eventos, separados por um espaço em branco.
         */
        this.hideOn = '';
        this.handleAnchorClick = (event) => {
            var _a;
            if (!(event.target instanceof Node)) {
                return;
            }
            // Se o click foi no trigger (ou dentro dele)
            if ((_a = this.trigger) === null || _a === void 0 ? void 0 : _a.contains(event.target)) {
                this.toggleDropdown();
            }
        };
        this.toggleDropdown = async () => {
            this.open ? this.hide() : this.show();
        };
    }
    watchOpen() {
        if (this.trigger) {
            this.handleTriggerAriaExpanded();
            this.handleTriggerTabindex();
        }
    }
    watchHideOn() {
        // Remove todos os eventos anteriores
        this.hideOnEventsMap.forEach((listener, eventName) => {
            this.content.removeEventListener(eventName, listener);
            this.hideOnEventsMap.delete(eventName);
        });
        // Adiciona todos os novos eventos
        this.addHideOnListeners();
    }
    async handleKeydown(event) {
        if (!this.open)
            return;
        if (event.key !== 'Escape')
            return;
        if (event.defaultPrevented)
            return;
        event.preventDefault();
        await this.hide();
        this.handleTriggerFocus();
    }
    /**
     * Método para abrir o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente exibido com essa chamada ao método.
     */
    async show() {
        if (this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcShow.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = true;
        this.alcAfterShow.emit();
        return true;
    }
    /**
     * Método para fechar o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente oculto com essa chamada ao método.
     */
    async hide() {
        if (!this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcHide.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = false;
        this.alcAfterHide.emit();
        return true;
    }
    handleTriggerFocus() {
        var _a;
        (_a = this.trigger) === null || _a === void 0 ? void 0 : _a.focus();
    }
    handleContentFocus() {
        const contentFirstFocusable = getFocusableElements(this.content)[0];
        if (!contentFirstFocusable)
            return;
        if (contentFirstFocusable instanceof HTMLElement) {
            contentFirstFocusable.focus();
        }
    }
    setTriggerAccessibility() {
        if (this.trigger.getAttribute('role') === null) {
            this.trigger.setAttribute('role', "button");
        }
        const contentElementChild = this.content.firstElementChild;
        if (this.trigger.getAttribute('aria-haspopup') === null) {
            const ariaHaspopup = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.role) === "menu" ? "menu" : "dialog";
            this.trigger.setAttribute('aria-haspopup', ariaHaspopup);
        }
        let id = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.id) ? contentElementChild.id : getUniqueId();
        // Se não ter conteudo dentro, o id vai no alc-dropdown__content se não vai no conteudo
        if (!contentElementChild) {
            this.content.id = id;
        }
        else {
            contentElementChild.id = id;
        }
        this.trigger.setAttribute('aria-controls', id);
    }
    handleTriggerAriaExpanded() {
        this.trigger.ariaExpanded = `${this.open}`;
    }
    handleTriggerTabindex() {
        this.trigger.tabIndex = this.open ? -1 : this.originalTriggerTabindex;
    }
    async handleFocusOut(e) {
        const { relatedTarget } = e;
        const isNode = relatedTarget instanceof Node;
        /*
          OBSERVAÇÃO:
          Para que um clique qualquer dentro de content, mesmo se for um elemento não focalizável,
          não resulte em relatedTarget null, foi definido tabindex=-1 para o content.
          Se não fosse assim, um clique em um elemento não focalizável dentro de content
          resultaria no fechamento indesejado do dropdown.
        */
        if (isNode && this.el.contains(relatedTarget)) {
            return;
        }
        await this.hide();
    }
    handleCloseOn(e) {
        if (e.defaultPrevented) {
            return;
        }
        this.open = false;
    }
    addHideOnListeners() {
        const hideOn = this.hideOn.trim();
        // Nada a fazer se for um string vazia.
        if (!hideOn) {
            return;
        }
        const eventNames = hideOn.split(/\s+/);
        eventNames.forEach(eventName => {
            const listener = (e) => this.handleCloseOn(e);
            this.hideOnEventsMap.set(eventName, listener);
            this.content.addEventListener(eventName, listener);
        });
    }
    componentDidUpdate() {
        if (this.open) {
            // Quando o trigger for acionado por teclado para abrir o foco deve ir para o primeiro elemento focalizável dentro do conteúdo
            // Foi adicionado para tratar no componentDidUpdate pois no handleKeydown o dropdown ainda esta fechado, logo o 'elemento.focus()' não funciona
            // Aqui o componente ja foi renderizado com o novo estado.
            this.handleContentFocus();
        }
    }
    getTrigger() {
        let slot = null;
        let trigger = null;
        slot = this.el.querySelector('[slot="trigger"]');
        if (slot) {
            if (slot.tagName === 'BUTTON' || slot.getAttribute('role') === 'button') {
                // Trigger é o próprio slot se ele mesmo for o botão
                trigger = slot;
            }
            else {
                // Trigger é o primeiro botão encontrado dentro do slot (se existir)
                trigger = slot.querySelector('button, [role="button"]');
            }
        }
        if (trigger === null) {
            logger.warn(this.el, 'alc-dropdown não localizou um trigger válido. Slot deve ser ou conter um botão. Veja a documentação para mais detalhes.');
        }
        return trigger;
    }
    componentDidLoad() {
        this.trigger = this.getTrigger();
        if (this.trigger) {
            this.setTriggerAccessibility();
            this.handleTriggerAriaExpanded();
            this.originalTriggerTabindex = this.trigger.tabIndex;
        }
        // Adiciona close-on listeners
        this.addHideOnListeners();
    }
    render() {
        return (h(Host, { key: '2a3cb9758c23c1f7f895322bffa6893a4680e1e8' }, h("alc-popup", { key: '0c352d9d09c09df64e50c0561633120705875ef1', active: this.open, placement: "bottom-start", flip: true, shift: true, strategy: "fixed", onFocusout: this.handleFocusOut.bind(this), distance: 2 }, h("div", { key: '6b60a206a5a326e53c1f3afed07b0e53b52c9832', slot: "anchor", onClick: this.handleAnchorClick }, h("slot", { key: '528d7a27ebf5bdc884d89796d3aec84ae19e18e5', name: "trigger" })), h("div", { key: '2407874043bb9e9cabfaf9bc13751040f15f0c18', class: "alc-dropdown__content", ref: (el) => this.content = el, tabindex: '-1' }, h("slot", { key: 'ecd68a468c536a351baa3c5eb75fad9fbd88c2b4' })))));
    }
    static get is() { return "alc-dropdown"; }
    static get originalStyleUrls() {
        return {
            "$": ["alc-dropdown.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["alc-dropdown.css"]
        };
    }
    static get properties() {
        return {
            "open": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Indica se o dropdown esta aberto ou n\u00E3o. Pode-se usar essa propriedade em vez dos m\u00E9todos show/hide."
                },
                "getter": false,
                "setter": false,
                "attribute": "open",
                "reflect": true,
                "defaultValue": "false"
            },
            "hideOn": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Nome do evento que, ao ocorrer no conte\u00FAdo do dropdown, vai fazer com que ele seja fechado.\nPodem ser informados v\u00E1rios eventos, separados por um espa\u00E7o em branco."
                },
                "getter": false,
                "setter": false,
                "attribute": "hide-on",
                "reflect": true,
                "defaultValue": "''"
            }
        };
    }
    static get events() {
        return [{
                "method": "alcShow",
                "name": "alc-show",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Evento disparado quando o dropdown vai abrir"
                },
                "complexType": {
                    "original": "null",
                    "resolved": "null",
                    "references": {}
                }
            }, {
                "method": "alcAfterShow",
                "name": "alc-after-show",
                "bubbles": true,
                "cancelable": false,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Evento disparado quando o dropdown abriu"
                },
                "complexType": {
                    "original": "null",
                    "resolved": "null",
                    "references": {}
                }
            }, {
                "method": "alcHide",
                "name": "alc-hide",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Evento disparado quando o dropdown vai fechar"
                },
                "complexType": {
                    "original": "null",
                    "resolved": "null",
                    "references": {}
                }
            }, {
                "method": "alcAfterHide",
                "name": "alc-after-hide",
                "bubbles": true,
                "cancelable": false,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Evento disparado quando o dropdown fechou"
                },
                "complexType": {
                    "original": "null",
                    "resolved": "null",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "show": {
                "complexType": {
                    "signature": "() => Promise<boolean>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<boolean>"
                },
                "docs": {
                    "text": "M\u00E9todo para abrir o dropdown.",
                    "tags": [{
                            "name": "returns",
                            "text": "O valor retornado \u00E9 `true` se o dropdown foi realmente exibido com essa chamada ao m\u00E9todo."
                        }]
                }
            },
            "hide": {
                "complexType": {
                    "signature": "() => Promise<boolean>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<boolean>"
                },
                "docs": {
                    "text": "M\u00E9todo para fechar o dropdown.",
                    "tags": [{
                            "name": "returns",
                            "text": "O valor retornado \u00E9 `true` se o dropdown foi realmente oculto com essa chamada ao m\u00E9todo."
                        }]
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "open",
                "methodName": "watchOpen"
            }, {
                "propName": "hideOn",
                "methodName": "watchHideOn"
            }];
    }
    static get listeners() {
        return [{
                "name": "keydown",
                "method": "handleKeydown",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=alc-dropdown.js.map
