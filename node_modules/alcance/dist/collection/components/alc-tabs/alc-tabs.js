import { Host, h, forceUpdate } from "@stencil/core";
import logger from "../utils/logger";
export class AlcTabs {
    constructor() {
        this.selectedTabButton = null;
        this.tabList = null;
        this.selectedTab = null;
        this.hasScroll = false;
        this.onTabClicked = (e) => {
            this.select(e.detail.tab);
        };
    }
    selectedChange(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.select(newValue);
        }
    }
    /**
     * Seleciona uma tab pelo valor de sua propriedade `tab` ou pela referência do elemento.
     *
     * @param tab A tab a ser selecionada. Se passada como string, deve ser o valor da propriedade `tab` da tab.
     */
    async select(tab) {
        const selectedTab = getTab(this.tabs, tab);
        if (!this.shouldSwitch(selectedTab)) {
            return false;
        }
        const selectedTabButton = getTabButton(this.tabButtons, selectedTab.getAttribute('tab'));
        this.tabSwitch(selectedTab, selectedTabButton);
        this.selected = selectedTab.getAttribute('tab');
        return true;
    }
    tabSwitch(selectedTab, selectedTabButton) {
        const leavingTab = this.selectedTab;
        const leavingTabButton = this.selectedTabButton;
        this.selectedTab = selectedTab;
        this.selectedTabButton = selectedTabButton;
        selectedTab.selected = true;
        selectedTabButton.selected = true;
        if (leavingTab !== selectedTab) {
            if (leavingTab) {
                leavingTab.selected = false;
                this.alcChange.emit({ tab: selectedTab.tab });
            }
            if (leavingTabButton) {
                leavingTabButton.selected = false;
            }
        }
    }
    // Evento disparado por alc-tab-button
    selectedHandler(e) {
        this.select(e.detail.tab);
    }
    selectedNextButton(e) {
        this.onTabButtonNext(e);
    }
    selectedPreviousButton(e) {
        this.onTabButtonPrevious(e);
    }
    selectedFirstButton(e) {
        this.onTabButtonFirst(e);
    }
    selectedLastButton(e) {
        this.onTabButtonLast(e);
    }
    shouldSwitch(selectedTab) {
        const leavingTab = this.selectedTab;
        return selectedTab !== undefined && selectedTab !== leavingTab;
    }
    get tabs() {
        let tabs = Array.from(this.el.querySelectorAll('alc-tab'));
        tabs = tabs.filter(t => t.closest('alc-tabs') === this.el);
        logger.log('my tabs are', tabs, this.el);
        return tabs;
    }
    get tabButtons() {
        let tabButtons = Array.from(this.el.querySelectorAll('alc-tab-button'));
        tabButtons = tabButtons.filter(b => b.closest('alc-tabs') === this.el);
        return tabButtons;
    }
    getNextButton(button) {
        let nextIndex;
        const buttonIndex = this.tabButtons.findIndex(b => b === button);
        // Último -> primeiro
        if (buttonIndex === this.tabButtons.length - 1) {
            nextIndex = 0;
        }
        else {
            nextIndex = buttonIndex + 1;
        }
        return this.tabButtons[nextIndex];
    }
    getPreviousButton(button) {
        let previousIndex;
        const buttonIndex = this.tabButtons.findIndex(b => b === button);
        // Primeiro -> último
        if (buttonIndex <= 0) {
            previousIndex = this.tabButtons.length - 1;
        }
        else {
            previousIndex = buttonIndex - 1;
        }
        return this.tabButtons[previousIndex];
    }
    handleScroll() {
        let scrollWidth = 0;
        let width = this.tabList.offsetWidth;
        let overflowX = this.tabList.style.overflowX;
        this.tabList.style.overflowX = 'auto';
        scrollWidth = this.tabList.scrollWidth;
        this.tabList.style.overflowX = overflowX;
        logger.log('width', width, scrollWidth);
        this.hasScroll = scrollWidth > width;
    }
    themeLoadedHandler() {
        this.handleScroll();
    }
    async componentDidLoad() {
        var _a;
        // Se selected não tiver sido indicado, a primeira será a inicial
        const initialTab = this.selected || ((_a = this.tabs[0]) === null || _a === void 0 ? void 0 : _a.tab);
        await this.select(initialTab);
        let slotButton = Array.from(this.el.querySelectorAll('[slot="button"]'));
        this.hasButtonSlot = slotButton.some(s => s.closest('alc-tabs') === this.el);
    }
    async onTabButtonNext(e) {
        if (!this.isValidTabButton(e))
            return;
        const target = e.target;
        const nextButton = this.getNextButton(target);
        this.handleSelectTabButton(nextButton);
    }
    async onTabButtonPrevious(e) {
        if (!this.isValidTabButton(e))
            return;
        const target = e.target;
        const previousButton = this.getPreviousButton(target);
        this.handleSelectTabButton(previousButton);
    }
    async onTabButtonFirst(e) {
        if (!this.isValidTabButton(e))
            return;
        const firstButton = this.tabButtons[0];
        this.handleSelectTabButton(firstButton);
    }
    async onTabButtonLast(e) {
        if (!this.isValidTabButton(e))
            return;
        const lastButton = this.tabButtons[this.tabButtons.length - 1];
        this.handleSelectTabButton(lastButton);
    }
    async handleSelectTabButton(tab) {
        const changed = await this.select(tab.tab);
        if (changed) {
            tab.querySelector('button').focus();
        }
    }
    isValidTabButton(e) {
        const target = e.target;
        return Array.from(this.tabButtons).includes(target);
    }
    componentDidRender() {
        var _a;
        /*
         O trecho abaixo permite que o componente seja atualizado
         sempre que houver mudanças no conteúdo (como a inclusão de "fihos").
         Isso foi feito para permitir, por exemplo, que uma tab seja
         adicionada pela simples manipulação do DOM.
         */
        (_a = this.mo) === null || _a === void 0 ? void 0 : _a.disconnect();
        this.mo = new MutationObserver(() => {
            forceUpdate(this.el);
        });
        this.mo.observe(this.el, { childList: true });
        this.mo.observe(this.el.querySelector('.alc-tabs'), { childList: true });
        this.tabs.map((tab, i) => {
            const tabpanel = tab.querySelector('[role="tabpanel"]');
            if (this.tabButtons.length <= i) {
                return;
            }
            const button = this.tabButtons[i].querySelector('button');
            if (!tabpanel.hasAttribute('id')) {
                tabpanel.setAttribute('id', `tab_${i}`);
            }
            if (!button.hasAttribute('id')) {
                button.setAttribute('id', `button_${i}`);
            }
            tabpanel.setAttribute('aria-labelledby', button.getAttribute('id'));
            button.setAttribute('aria-controls', tabpanel.getAttribute('id'));
        });
        // this.handleScroll();
    }
    disconnectedCallback() {
        var _a;
        (_a = this.mo) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    render() {
        let tabList;
        if (!this.hasButtonSlot) {
            tabList = this.tabs.map((tab) => {
                // Não parece ser um boa ideia criar esses elementos dinamicamente, dessa forma
                // Fazendo assim, a inclusão de uma nova tab no DOM, por exemplo, não
                // reflete automaticamente aqui, porque não ocorre o "render".
                return (h("alc-tab-button", { tab: tab.tab }, tab.label));
            });
        }
        logger.log('rendering', this.el, tabList);
        return (h(Host, { onAlcTabButtonClick: this.onTabClicked, onAlcTabButtonNext: this.onTabButtonNext.bind(this), onAlcTabButtonPrevious: this.onTabButtonPrevious.bind(this) }, h("div", { class: "alc-tabs" }, h("alc-scroll-panel", { hasFocus: false, scrollToElement: this.selectedTabButton }, h("div", { role: "tablist", ref: el => this.tabList = el, class: "alc-tabs__tab-list" }, h("slot", { name: "button" }), tabList)), h("slot", null))));
    }
    static get is() { return "alc-tabs"; }
    static get originalStyleUrls() {
        return {
            "base": ["alc-tabs-base.css"],
            "theme": ["alc-tabs.css"]
        };
    }
    static get styleUrls() {
        return {
            "base": ["alc-tabs-base.css"],
            "theme": ["alc-tabs.css"]
        };
    }
    static get properties() {
        return {
            "selected": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "O identificador da tab atualmente selecionada"
                },
                "getter": false,
                "setter": false,
                "attribute": "selected",
                "reflect": true
            }
        };
    }
    static get states() {
        return {
            "selectedTab": {},
            "hasScroll": {}
        };
    }
    static get events() {
        return [{
                "method": "alcChange",
                "name": "alc-change",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Disparado quando houve uma mudan\u00E7a de tab"
                },
                "complexType": {
                    "original": "{\n    tab: string\n  }",
                    "resolved": "{ tab: string; }",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "select": {
                "complexType": {
                    "signature": "(tab: string | HTMLAlcTabElement) => Promise<boolean>",
                    "parameters": [{
                            "name": "tab",
                            "type": "string | HTMLAlcTabElement",
                            "docs": "A tab a ser selecionada. Se passada como string, deve ser o valor da propriedade `tab` da tab."
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "HTMLAlcTabElement": {
                            "location": "global",
                            "id": "global::HTMLAlcTabElement"
                        }
                    },
                    "return": "Promise<boolean>"
                },
                "docs": {
                    "text": "Seleciona uma tab pelo valor de sua propriedade `tab` ou pela refer\u00EAncia do elemento.",
                    "tags": [{
                            "name": "param",
                            "text": "tab A tab a ser selecionada. Se passada como string, deve ser o valor da propriedade `tab` da tab."
                        }]
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "selected",
                "methodName": "selectedChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "alc-click",
                "method": "selectedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "alc-next",
                "method": "selectedNextButton",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "alc-previous",
                "method": "selectedPreviousButton",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "alc-first",
                "method": "selectedFirstButton",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "alc-last",
                "method": "selectedLastButton",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "themeLoaded",
                "method": "themeLoadedHandler",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
const getTab = (tabs, tab) => {
    const tabEl = (typeof tab === 'string')
        ? tabs.find(t => t.tab === tab)
        : tab;
    if (!tabEl) {
        logger.error(`tab with id: "${tabEl}" does not exist`);
    }
    return tabEl;
};
const getTabButton = (buttons, tab) => {
    const buttonEl = buttons.find(b => b.tab === tab);
    if (!buttonEl) {
        logger.error(`tab button with id: "${buttonEl}" does not exist`);
    }
    return buttonEl;
};
//# sourceMappingURL=alc-tabs.js.map
