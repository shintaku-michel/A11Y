import { Host, h } from "@stencil/core";
import { computePosition, flip, shift, autoUpdate, size, offset, arrow } from "@floating-ui/dom";
/**
 * @slot DEFAULT - Slot para o elemento principal do popup.
 *
 * @slot anchor - Slot que serve como âncora e aciona a abertura do popup.
*/
export class AlcPopup {
    constructor() {
        this.padding = 8;
        /**
        * Aciona a abertura do popup.
        */
        this.active = false;
        /**
        * Define o posicionamento do popup.
        */
        this.placement = 'bottom';
        /**
        * Quando definido como `true`, troca o posicionamento (placement) do popup para mantê-lo visível.
        */
        this.flip = false;
        /**
        * Quando definido como `true`, desloca o popup ao longo do eixo para mantê-lo visível quando cortado.
        */
        this.shift = false;
        /**
        * Determina como o pop-up é posicionado. A estratégia `absoluta` funciona bem na maioria dos casos.
        * Se o overflow cortar o popup, usar a posição `fixed` muitas vezes pode contornar isso.
        */
        this.strategy = 'absolute';
        /**
        * Define a distância entre o popup e âncora.
        */
        this.distance = 0;
        /** Syncs the popup's width or height to that of the anchor element. */
        this.sync = null;
        /**
        *  Adiciona arrow no popup.
        */
        this.arrow = false;
    }
    watchActive(newValue) {
        if (newValue) {
            // Ao ativar, start;
            this.start();
        }
        else {
            // Ao desativar, cleanup
            if (this.cleanup) {
                this.cleanup();
            }
        }
    }
    componentDidLoad() {
        if (this.active) {
            this.start();
        }
    }
    disconnectedCallback() {
        if (this.cleanup) {
            this.cleanup();
        }
    }
    start() {
        if (!this.anchorEl || !this.popupEl) {
            return;
        }
        // autoUpdate retorna uma função para limpar os event listeners
        this.cleanup = autoUpdate(this.anchorEl, this.popupEl, () => {
            this.reposition();
        });
    }
    reposition() {
        const middleware = this.resolveMiddleware();
        computePosition(this.anchorEl, this.popupEl, {
            placement: this.placement,
            middleware,
            strategy: this.strategy,
        }).then(({ x, y, middlewareData, placement }) => {
            // Descobri que aqui da para colocar o 'transform: translate()';
            Object.assign(this.popupEl.style, {
                left: `${x}px`,
                top: `${y}px`,
            });
            const staticSide = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' }[placement.split('-')[0]];
            if (middlewareData.arrow) {
                const { x, y, centerOffset } = middlewareData.arrow;
                const rotate = { top: 225, right: 315, bottom: 45, left: 135 };
                let top = '';
                let left = '';
                const incValue = Math.sign(centerOffset) * -3;
                if (placement === 'bottom' || placement === 'top') {
                    left = `${x + incValue}px`;
                }
                else {
                    top = `${y + incValue}px`;
                }
                // Reseta os valores de top e bottom antes de atribuir o valor a um deles, se não fica os dois valores e buga a posição do arrow.
                Object.assign(this.arrowEl.style, {
                    bottom: '',
                    right: '',
                    top,
                    left,
                    [staticSide]: `${-this.arrowEl.offsetWidth / 2}px`,
                    transform: `rotate(${rotate[staticSide]}deg)`
                });
            }
        });
    }
    resolveMiddleware() {
        const padding = this.padding;
        const middleware = [
            offset({ mainAxis: this.distance })
        ];
        // Aqui temos as funções prontas do floating-ui mas podemos customizar e/ou criar se for necessário.
        if (this.flip) {
            middleware.push(flip({
                padding: padding,
            }));
        }
        // middleware.push(
        //   size({
        //     apply({rects, availableWidth, availableHeight, elements}) {
        //       Object.assign(elements.floating.style, {
        //         maxWidth: `${availableWidth - padding}px`,
        //         maxHeight: `${availableHeight - padding}px`,
        //         width: `${rects.reference.width}px`,
        //       });
        //     },
        //   }),
        // );
        middleware.push(size({
            apply: ({ rects, availableWidth, availableHeight, elements }) => {
                if (this.sync) {
                    const syncWidth = this.sync === 'width' || this.sync === 'both';
                    const syncHeight = this.sync === 'height' || this.sync === 'both';
                    Object.assign(elements.floating.style, {
                        width: syncWidth ? `${rects.reference.width}px` : '',
                        height: syncHeight ? `${rects.reference.width}px` : '',
                    });
                }
                else {
                    Object.assign(elements.floating.style, {
                        width: '',
                        height: '',
                    });
                }
                // Object.assign(elements.floating.style, {
                //   maxWidth: `${availableWidth - padding}px`,
                //   maxHeight: `${availableHeight - padding}px`,
                // });
            }
        }));
        if (this.shift) {
            middleware.push(shift({ padding: padding }));
        }
        if (this.arrow) {
            middleware.push(arrow({ element: this.arrowEl }));
        }
        return middleware;
    }
    render() {
        return (h(Host, { key: 'b0d9dc5b6ecaea7e890b354ad784867477c746b2' }, h("div", { key: 'aad811091ef55a2ef72eed027e63ceea97a358cc', ref: (el) => this.anchorEl = el }, h("slot", { key: 'baba256e7df545e6fc6c667e03ff2344f2013db1', name: "anchor" })), h("div", { key: 'ab9285834ac4eb48c8633cc6adc336589e87660e', class: {
                'alc-popup__content': true,
                'alc-popup__content--active': this.active,
                'alc-popup__content--fixed': this.strategy === 'fixed',
            }, ref: (el) => this.popupEl = el }, h("slot", { key: 'a702544be7061ef03f84d75cd9cafb7e2bb933e9' }), h("div", { key: '6e1f20ded951cfacfd406820d08637e7dff76c93', ref: (el) => this.arrowEl = el, class: this.arrow ? 'alc-popup__arrow' : '' }))));
    }
    static get is() { return "alc-popup"; }
    static get originalStyleUrls() {
        return {
            "$": ["alc-popup.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["alc-popup.css"]
        };
    }
    static get properties() {
        return {
            "active": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Aciona a abertura do popup."
                },
                "getter": false,
                "setter": false,
                "attribute": "active",
                "reflect": true,
                "defaultValue": "false"
            },
            "placement": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "PopupPlacement",
                    "resolved": "\"bottom\" | \"bottom-end\" | \"bottom-start\" | \"left\" | \"left-end\" | \"left-start\" | \"right\" | \"right-end\" | \"right-start\" | \"top\" | \"top-end\" | \"top-start\"",
                    "references": {
                        "PopupPlacement": {
                            "location": "local",
                            "path": "/home/jenkins_slave/workspace/alcance-snapshots/packages/alcance/src/components/alc-popup/alc-popup.tsx",
                            "id": "src/components/alc-popup/alc-popup.tsx::PopupPlacement"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Define o posicionamento do popup."
                },
                "getter": false,
                "setter": false,
                "attribute": "placement",
                "reflect": true,
                "defaultValue": "'bottom'"
            },
            "flip": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Quando definido como `true`, troca o posicionamento (placement) do popup para mant\u00EA-lo vis\u00EDvel."
                },
                "getter": false,
                "setter": false,
                "attribute": "flip",
                "reflect": true,
                "defaultValue": "false"
            },
            "shift": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Quando definido como `true`, desloca o popup ao longo do eixo para mant\u00EA-lo vis\u00EDvel quando cortado."
                },
                "getter": false,
                "setter": false,
                "attribute": "shift",
                "reflect": true,
                "defaultValue": "false"
            },
            "strategy": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'absolute' | 'fixed'",
                    "resolved": "\"absolute\" | \"fixed\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Determina como o pop-up \u00E9 posicionado. A estrat\u00E9gia `absoluta` funciona bem na maioria dos casos.\nSe o overflow cortar o popup, usar a posi\u00E7\u00E3o `fixed` muitas vezes pode contornar isso."
                },
                "getter": false,
                "setter": false,
                "attribute": "strategy",
                "reflect": true,
                "defaultValue": "'absolute'"
            },
            "distance": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Define a dist\u00E2ncia entre o popup e \u00E2ncora."
                },
                "getter": false,
                "setter": false,
                "attribute": "distance",
                "reflect": true,
                "defaultValue": "0"
            },
            "sync": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'width' | 'height' | 'both'",
                    "resolved": "\"both\" | \"height\" | \"width\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Syncs the popup's width or height to that of the anchor element."
                },
                "getter": false,
                "setter": false,
                "attribute": "sync",
                "reflect": true,
                "defaultValue": "null"
            },
            "arrow": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Adiciona arrow no popup."
                },
                "getter": false,
                "setter": false,
                "attribute": "arrow",
                "reflect": true,
                "defaultValue": "false"
            }
        };
    }
    static get watchers() {
        return [{
                "propName": "active",
                "methodName": "watchActive"
            }];
    }
}
//# sourceMappingURL=alc-popup.js.map
