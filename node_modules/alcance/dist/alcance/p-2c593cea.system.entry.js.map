{"version":3,"names":["CACHED_MAP","getIconMap","window","Map","win","Ionicons","map","getUrl","i","url","getSrc","src","getName","name","icon","getNamedUrl","iconName","get","getAssetPath","concat","isSrc","isStr","toLower","trim","invalidChars","replace","str","length","test","val","toLowerCase","inheritAttributes","el","attributes","attributeObject","forEach","attr","hasAttribute","value","getAttribute","removeAttribute","validateContent","svgContent","div","document","createElement","innerHTML","childNodes","nodeName","removeChild","svgElm","firstElementChild","svgClass","setAttribute","isValid","elm","nodeType","indexOf","alciconContent","requests","addSvgClass","className","querySelector","classList","add","getSvgContent","sanitize","req","fetch","then","rsp","ok","text","set","Promise","resolve","alcIconCss","AlcIcon","exports","class_1","hostRef","_this","this","inheritedAttributes","role","isVisible","flipRtl","lazy","hasAriaHidden","prototype","componentWillLoad","connectedCallback","waitUntilVisible","loadIcon","disconnectedCallback","io","disconnect","undefined","rootMargin","cb","IntersectionObserver","io_1","data","isIntersecting","observe","url_1","has","logger","log","label","ariaLabel","render","_a","report","tagName","_b","h","Host","Object","assign","key","class","ownerDocument","dir"],"sources":["src/components/alc-icon/utils.ts","src/components/alc-icon/validate.ts","src/components/alc-icon/request.ts","src/components/alc-icon/alc-icon.css?tag=alc-icon","src/components/alc-icon/alc-icon.tsx"],"sourcesContent":["import { getAssetPath } from '@stencil/core';\nimport { AlcIcon as Icon } from './alc-icon';\n\n\nlet CACHED_MAP: Map<string, string>;\n\nexport const getIconMap = (): Map<string, string> => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  } else {\n    if (!CACHED_MAP) {\n      const win = window as any;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\n\nexport const addIcons = (icons: { [name: string]: string; }) => {\n  const map = getIconMap();\n  Object.keys(icons).forEach(name => map.set(name, icons[name]));\n};\n\n\nexport const getUrl = (i: Icon) => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n\n  url = getName(i.name, i.icon);\n  if (url) {\n    return getNamedUrl(url);\n  }\n\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n  }\n\n  return null;\n};\n\n\nconst getNamedUrl = (iconName: string) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  return getAssetPath(`assets/icons/${iconName}.svg`);\n};\n\n\nexport const getName = (\n  iconName: string | undefined,\n  icon: string | undefined\n) => {\n\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n  }\n  \n  if (isStr(iconName)) {\n      iconName = toLower(iconName);\n  }\n\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n\n  return iconName;\n};\n\nexport const getSrc = (src: string | undefined) => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\n\nexport const isSrc = (str: string) => str.length > 0 && /(\\/|\\.)/.test(str);\n\nexport const isStr = (val: any): val is string => typeof val === 'string';\n\nexport const toLower = (val: string) => val.toLowerCase();\n\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nexport const inheritAttributes = (el: HTMLElement, attributes: string[] = []) => {\n  const attributeObject: { [k: string]: any } = {};\n\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n\n  return attributeObject;\n}","import { isStr } from './utils';\n\nexport const validateContent = (svgContent: string) => {\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n\n  // setup this way to ensure it works on our buddy IE\n  for (let i = div.childNodes.length - 1; i >= 0; i--) {\n    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n      div.removeChild(div.childNodes[i]);\n    }\n  }\n\n  // must only have 1 root element\n  const svgElm = div.firstElementChild;\n  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n    const svgClass = svgElm.getAttribute('class') || '';\n    svgElm.setAttribute('class', (svgClass + ' alc-icon__image').trim());\n\n    // root element must be an svg\n    // lets double check we've got valid elements\n    // do not allow scripts\n    if (isValid(svgElm as any)) {\n      return div.innerHTML;\n    }\n  }\n  return '';\n};\n\nexport const isValid = (elm: HTMLElement) => {\n  if (elm.nodeType === 1) {\n    if (elm.nodeName.toLowerCase() === 'script') {\n      return false;\n    }\n\n    for (let i = 0; i < elm.attributes.length; i++) {\n      const val = elm.attributes[i].nodeName;\n      if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\n        return false;\n      }\n    }\n\n    for (let i = 0; i < elm.childNodes.length; i++) {\n      if (!isValid(elm.childNodes[i] as any)) {\n        return false;\n      }\n    }\n  }\n  return true;\n};","import { validateContent } from './validate';\n\nexport const alciconContent = new Map<string, string>();\nconst requests = new Map<string, Promise<any>>();\n\n/*\n * Originalmente, a função validateContent (importada acima) inseria uma classe\n * no elemento svg obtido. Precisávamos de outra classe (do Alcance, não o ionic),\n * e que essa classe fosse inserida sempre, independentemente de validação.\n * Por isso foi criada essa função aqui. Desse modo, o svg obtido já fica com\n * a classe devida antes de ir para o cache.\n *\n * Obs.: A inclusão da classe dentro da função de validação (como feito originalmente\n * pela equipe do ionic) parece ser um desvio do objetivo da função.\n */\nconst addSvgClass = (svgContent: string, className: string): string => {\n  // Cria container temporário para o svg\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // Adiciona a classe necessária no svg\n  div.querySelector('svg').classList.add(className);\n  // Atualiza string HTML do svg.\n  return div.innerHTML;\n}\n\nexport const getSvgContent = (url: string, sanitize: boolean) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            if (svgContent) {\n              svgContent = addSvgClass(svgContent, 'alc-icon__image');\n            }\n            alciconContent.set(url, svgContent || '');\n          });\n        }\n        alciconContent.set(url, '');\n      });\n\n      // cache for the same requests\n      requests.set(url, req);\n    } else {\n      // set to empty for ssr scenarios and resolve promise\n      alciconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n\n  return req;\n};","alc-icon {\n  /* @apply flex-none w-4 text-center; */\n  @apply inline-block;\n}\n\n/* @TODO Rever o nome dessa classe */\n.icon-inner {\n  @apply inline-flex items-center;\n}\n\nalc-icon.size-x-small {\n  @apply text-xs;\n}\n\nalc-icon.size-small {\n  @apply text-sm;\n}\n\nalc-icon.size-medium {\n  @apply text-base;\n}\n\nalc-icon.size-large {\n  @apply text-lg;\n}\n\nalc-icon.size-x-large {\n  @apply text-xl;\n}\n\nalc-icon.size-xx-large {\n  @apply text-2xl;\n}\n\n.alc-icon__image {\n  /* Medidas em 'em' para poder variar de acordo com o tamanho do texto\n     que no qual está inserido. */\n  @apply w-[1em] h-[1em] -mt-[0.125em] top-[0.125em] relative;\n}\n","import { Build, Component, Element, Host, Prop, State, Watch, h } from '@stencil/core';\nimport logger from '../utils/logger';\nimport { getSvgContent, alciconContent } from './request';\nimport { /* getName , */ getUrl, inheritAttributes } from './utils';\n\n@Component({\n  tag: 'alc-icon',\n  assetsDirs: ['assets/icons'],\n  styleUrl: 'alc-icon.css',\n  scoped: false,\n})\nexport class AlcIcon {\n  private io?: IntersectionObserver;\n  private iconName: string | null = null;\n  private inheritedAttributes: { [k: string]: any } = {};\n  private role: 'img' | 'presentation' = 'img';\n\n  @Element() el!: HTMLElement;\n\n  @State() private svgContent?: string;\n  @State() private isVisible = false;\n  @State() private ariaLabel?: string;\n\n  /**\n   * Equivalente textual do ícone. Seu uso é semelhante ao atributo `alt` de uma imagem.\n   * Esse texto será lido por software leitor de tela, e utilizado no lugar do ícone se por qualquer motivo a imagem não puder ser carregada no navegador.\n   */\n  @Prop({ reflect: true }) label!: string;\n\n  /**\n   * Define se o ícone deve ser espelhado horizontalmente quando `dir` for `\"rtl\"`.\n   */\n  @Prop({ reflect: true }) flipRtl?: boolean = false;\n\n  /**\n   * Nome do ícone que será mostrado. Deve ser um dos nomes de ícone da biblioteca.\n   */\n  @Prop({ reflect: true }) name?: string;\n\n  /**\n   * Especifica o `src` de um arquivo SVG a ser usado como ícone.\n   */\n  @Prop({ reflect: true }) src?: string;\n\n  /**\n   * Uma combinação de `name` e `src`.\n   * Se o valor for entendido como a URL de um `src`, ele definirá a propriedade `src`.\n   * Caso contrário, assume-se como o nome de ícone da biblioteca, e define a propriedade `name`.\n   */\n  @Prop({ reflect: true }) icon?: string;\n\n  /**\n   * Se ativado, a carga do ícone ocorrerá somente quando o componente estiver visível na _viewport_.\n   */\n  @Prop({ reflect: true }) lazy = false;\n\n  /**\n   * Quando definido como `true`, o conteúdo SVG obtido via HTTP passará por uma limpeza.\n   * Conteúdo que contenha algum elemento `<script>` ou atributo que comece com `on`, como `onclick`, será descartado.\n   * Sendo descartado, a imagem não será mostrada.\n   * @default false\n   */\n  @Prop({ reflect: true }) sanitize = false;\n\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n  }\n\n  connectedCallback() {\n    // purposely do not return the promise here because loading\n    // the svg file should not hold up loading the app\n    // only load the svg if it's visible\n    this.waitUntilVisible(this.el, '50px', () => {\n      this.isVisible = true;\n      this.loadIcon();\n    });\n  }\n\n  disconnectedCallback() {\n    if (this.io) {\n      this.io.disconnect();\n      this.io = undefined;\n    }\n  }\n\n  private waitUntilVisible(el: HTMLElement, rootMargin: string, cb: () => void) {\n    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && (window as any).IntersectionObserver) {\n      const io = (this.io = new (window as any).IntersectionObserver(\n        (data: IntersectionObserverEntry[]) => {\n          if (data[0].isIntersecting) {\n            io.disconnect();\n            this.io = undefined;\n            cb();\n          }\n        },\n        { rootMargin },\n      ));\n\n      io.observe(el);\n    } else {\n      // browser doesn't support IntersectionObserver\n      // so just fallback to always show it\n      cb();\n    }\n  }\n  \n  private hasAriaHidden = () => {\n    const { el } = this;\n    \n    return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';\n  }\n\n  @Watch('label')\n  @Watch('name')\n  @Watch('src')\n  @Watch('icon')\n  loadIcon() {\n    if (Build.isBrowser && this.isVisible) {\n      const url = getUrl(this);\n      if (url) {\n        if (alciconContent.has(url)) {\n          // sync if it's already loaded\n          this.svgContent = alciconContent.get(url);\n          logger.log(this.svgContent);\n        } else {\n          // async if it hasn't been loaded\n          getSvgContent(url, this.sanitize).then(() => (this.svgContent = alciconContent.get(url)));\n        }\n      }\n    }\n\n    // Se label estiver preenchido\n    if (this.label) {\n      this.ariaLabel = this.label;\n      this.role = 'img';\n    }\n    // Se label for um string vazio\n    else if (this.label === '') {\n      this.ariaLabel = undefined;\n      this.role = 'presentation';\n    }\n  }\n\n\n  render() {\n    this.label ?? logger.report('label', this.el.tagName.toLowerCase(), this.el)\n    const { label, iconName, ariaLabel, inheritedAttributes, role } = this;\n    const flipRtl =\n      this.flipRtl ||\n      (iconName &&\n        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&\n        this.flipRtl !== false);\n\n    /**\n     * Only set the aria-label if a) we have generated\n     * one for the icon and if aria-hidden is not set to \"true\".\n     * If developer wants to set their own aria-label, then\n     * inheritedAttributes down below will override whatever\n     * default label we have set.\n     */\n    return (\n      <Host\n        label={label}\n        aria-label={ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null}\n        role={role}\n        class={{\n          'flip-rtl': !!flipRtl && (this.el.ownerDocument as Document).dir === 'rtl',\n        }}\n        {...inheritedAttributes}\n      >\n        {Build.isBrowser && this.svgContent ? (\n          <span class=\"icon-inner\" innerHTML={this.svgContent}></span>\n        ) : (\n          <span class=\"icon-inner\">{label}</span>\n        )}\n      </Host>\n    );\n  }\n}"],"mappings":"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","ignoreList":[]}