{"version":3,"names":["alcTabsBaseCss","themeAlcTabsCss","AlcTabs","exports","class_1","hostRef","_this","this","selectedTabButton","tabList","selectedTab","hasScroll","onTabClicked","e","select","detail","tab","prototype","selectedChange","newValue","oldValue","getTab","tabs","shouldSwitch","getTabButton","tabButtons","getAttribute","tabSwitch","selected","leavingTab","leavingTabButton","alcChange","emit","selectedHandler","selectedNextButton","onTabButtonNext","selectedPreviousButton","onTabButtonPrevious","selectedFirstButton","onTabButtonFirst","selectedLastButton","onTabButtonLast","undefined","Object","defineProperty","Array","from","el","querySelectorAll","filter","t","closest","logger","log","b","getNextButton","button","nextIndex","buttonIndex","findIndex","length","getPreviousButton","previousIndex","handleScroll","scrollWidth","width","offsetWidth","overflowX","style","themeLoadedHandler","componentDidLoad","initialTab","_a","_b","sent","slotButton","hasButtonSlot","some","s","isValidTabButton","target","nextButton","handleSelectTabButton","previousButton","firstButton","lastButton","changed","querySelector","focus","includes","componentDidRender","mo","disconnect","MutationObserver","forceUpdate","observe","childList","map","i","tabpanel","hasAttribute","setAttribute","concat","disconnectedCallback","render","h","label","Host","onAlcTabButtonClick","onAlcTabButtonNext","bind","onAlcTabButtonPrevious","class","hasFocus","scrollToElement","role","ref","name","tabEl","find","error","buttons","buttonEl"],"sources":["src/components/alc-tabs/alc-tabs-base.css?tag=alc-tabs&mode=base","src/components/alc-tabs/alc-tabs.css?tag=alc-tabs&mode=theme","src/components/alc-tabs/alc-tabs.tsx"],"sourcesContent":["/* CSS básico para que o componente funcione - sem dependências externas */\nalc-tabs {\n  @apply block;\n}\n\n.alc-tabs {\n  @apply border border-solid;\n}\n\n.alc-tabs__tab-list {\n  @apply border-0 border-b border-dotted;\n}","alc-tabs {\n  /**\n   * @prop --bg-color: Cor de fundo da tab ativa e seu conteúdo.\n   */\n  --bg-color: var(--alc-color-surface);\n\n  --border-color: var(--alc-color-border);\n  --border-width: var(--alc-border-width);\n\n}\n\n/* Definição das variáveis - Setup dos temas*/\n[data-alc-theme=\"light\"] alc-tabs {\n  --outline-color: var(--alc-color-action-60);\n}\n\n[data-alc-theme=\"dark\"] alc-tabs {\n  --outline-color: var(--alc-color-action-30);\n}","import { Component, Host, h, Element, Prop, Listen, Watch, State, Event, EventEmitter, Method, forceUpdate } from '@stencil/core';\n\nimport { TabButtonClickEventDetail } from '../alc-tab-button/alc-tab-button-interface';\nimport logger from '../utils/logger';\n\nexport interface AlcTabsDidChangeEventTypes {\n  tab: string\n}\n\n@Component({\n  tag: 'alc-tabs',\n  styleUrls: {\n    base: 'alc-tabs-base.css',\n    theme: 'alc-tabs.css'\n  },\n  scoped: false\n})\nexport class AlcTabs {\n\n  private hasButtonSlot: boolean;\n\n  private selectedTabButton?: HTMLAlcTabButtonElement = null;\n\n  private tabList: HTMLDivElement = null;\n\n  private mo: MutationObserver;\n\n  /**\n   * O identificador da tab atualmente selecionada\n   */\n  @Prop({ mutable: true, reflect: true }) selected: string;\n\n  @Watch('selected')\n  selectedChange(newValue: string, oldValue: string) {\n    if (newValue !== oldValue) {\n      this.select(newValue);\n    }\n  }\n\n  @Element() el!: HTMLAlcTabsElement;\n\n  @State() selectedTab?: HTMLAlcTabElement = null;\n\n  @State() hasScroll = false;\n\n  /**\n   * Disparado quando houve uma mudança de tab\n   */\n  @Event({\n    eventName: 'alc-change'\n  }) alcChange!: EventEmitter<{\n    tab: string\n  }>;\n\n  /**\n   * Seleciona uma tab pelo valor de sua propriedade `tab` ou pela referência do elemento.\n   *\n   * @param tab A tab a ser selecionada. Se passada como string, deve ser o valor da propriedade `tab` da tab.\n   */\n  @Method()\n  async select(tab: string | HTMLAlcTabElement): Promise<boolean> {\n    const selectedTab = getTab(this.tabs, tab);\n    if (!this.shouldSwitch(selectedTab)) {\n      return false;\n    }\n    const selectedTabButton = getTabButton(this.tabButtons, selectedTab.getAttribute('tab'));\n    this.tabSwitch(selectedTab, selectedTabButton);\n\n    this.selected = selectedTab.getAttribute('tab');\n    return true;\n  }\n\n  private tabSwitch(selectedTab: HTMLAlcTabElement, selectedTabButton: HTMLAlcTabButtonElement) {\n    const leavingTab = this.selectedTab;\n    const leavingTabButton = this.selectedTabButton;\n    this.selectedTab = selectedTab;\n    this.selectedTabButton = selectedTabButton;\n\n    selectedTab.selected = true;\n    selectedTabButton.selected = true;\n\n    if (leavingTab !== selectedTab) {\n      if (leavingTab) {\n        leavingTab.selected = false;\n        this.alcChange.emit({ tab: selectedTab.tab });\n      }\n      if (leavingTabButton) {\n        leavingTabButton.selected = false;\n      }\n    }\n  }\n\n  // Evento disparado por alc-tab-button\n  @Listen('alc-click')\n  selectedHandler(e: CustomEvent) {\n    this.select(e.detail.tab);\n  }\n\n  @Listen('alc-next')\n  selectedNextButton(e: CustomEvent) {\n    this.onTabButtonNext(e)\n  }\n\n  @Listen('alc-previous')\n  selectedPreviousButton(e: CustomEvent) {\n    this.onTabButtonPrevious(e)\n  }\n\n  @Listen('alc-first')\n  selectedFirstButton(e: CustomEvent) {\n    this.onTabButtonFirst(e);\n  }\n\n  @Listen('alc-last')\n  selectedLastButton(e: CustomEvent) {\n    this.onTabButtonLast(e);\n  }\n\n  private shouldSwitch(selectedTab: HTMLAlcTabElement | undefined): selectedTab is HTMLAlcTabElement {\n    const leavingTab = this.selectedTab;\n    return selectedTab !== undefined && selectedTab !== leavingTab;\n  }\n\n  private get tabs() {\n    let tabs = Array.from(this.el.querySelectorAll('alc-tab'));\n    tabs = tabs.filter(t => t.closest('alc-tabs') === this.el);\n    logger.log('my tabs are', tabs, this.el);\n    return tabs;\n  }\n\n  private get tabButtons() {\n    let tabButtons = Array.from(this.el.querySelectorAll('alc-tab-button'));\n    tabButtons = tabButtons.filter(b => b.closest('alc-tabs') === this.el)\n    return tabButtons;\n  }\n\n  private getNextButton(button: HTMLAlcTabButtonElement ) {\n\n    let nextIndex: number;\n    const buttonIndex = this.tabButtons.findIndex(b => b === button);\n\n    // Último -> primeiro\n    if (buttonIndex === this.tabButtons.length - 1) {\n      nextIndex = 0;\n    }\n    else {\n      nextIndex = buttonIndex + 1;\n    }\n\n    return this.tabButtons[nextIndex];\n  }\n\n  private getPreviousButton(button: HTMLAlcTabButtonElement ) {\n\n    let previousIndex: number;\n    const buttonIndex = this.tabButtons.findIndex(b => b === button);\n\n\n    // Primeiro -> último\n    if (buttonIndex <= 0) {\n      previousIndex = this.tabButtons.length - 1;\n    }\n    else {\n      previousIndex = buttonIndex - 1;\n    }\n\n    return this.tabButtons[previousIndex];\n  }\n\n  private handleScroll() {\n    let scrollWidth = 0;\n    let width = this.tabList.offsetWidth;\n    let overflowX = this.tabList.style.overflowX;\n\n    this.tabList.style.overflowX = 'auto';\n    scrollWidth = this.tabList.scrollWidth;\n    this.tabList.style.overflowX = overflowX;\n\n    logger.log('width', width, scrollWidth);\n\n    this.hasScroll = scrollWidth > width;\n  }\n\n  @Listen('themeLoaded', {\n    target: 'window'\n  })\n  themeLoadedHandler() {\n    this.handleScroll();\n  }\n\n  async componentDidLoad() {\n    // Se selected não tiver sido indicado, a primeira será a inicial\n    const initialTab = this.selected || this.tabs[0]?.tab;\n\n    await this.select(initialTab);\n\n    let slotButton = Array.from(this.el.querySelectorAll('[slot=\"button\"]'));\n    this.hasButtonSlot = slotButton.some(s => s.closest('alc-tabs') === this.el);\n  }\n\n  private onTabClicked = (e: CustomEvent<TabButtonClickEventDetail>) => {\n    this.select(e.detail.tab);\n  }\n\n  private async onTabButtonNext (e: CustomEvent) {\n    if(!this.isValidTabButton(e)) return;\n    \n    const target = e.target as HTMLAlcTabButtonElement;\n\n    const nextButton = this.getNextButton(target);\n    this.handleSelectTabButton(nextButton);\n  }\n\n  private async onTabButtonPrevious (e: CustomEvent) {\n    if(!this.isValidTabButton(e)) return;\n\n    const target = e.target as HTMLAlcTabButtonElement;\n\n    const previousButton = this.getPreviousButton(target);\n    this.handleSelectTabButton(previousButton);\n  }\n\n  private async onTabButtonFirst (e: CustomEvent) {\n    if(!this.isValidTabButton(e)) return;\n\n    const firstButton = this.tabButtons[0];\n    this.handleSelectTabButton(firstButton);\n  }\n\n  private async onTabButtonLast (e: CustomEvent) {\n    if(!this.isValidTabButton(e)) return;\n\n    const lastButton = this.tabButtons[this.tabButtons.length - 1];\n    this.handleSelectTabButton(lastButton);\n  }\n\n  private async handleSelectTabButton(tab: HTMLAlcTabButtonElement) {\n    const changed = await this.select(tab.tab);\n    if (changed) {\n      tab.querySelector('button').focus();\n    }\n  }\n\n  private isValidTabButton(e: CustomEvent) {\n    const target = e.target as HTMLAlcTabButtonElement;\n    return Array.from(this.tabButtons).includes(target);\n  }\n\n  componentDidRender() {\n\n    /*\n     O trecho abaixo permite que o componente seja atualizado\n     sempre que houver mudanças no conteúdo (como a inclusão de \"fihos\").\n     Isso foi feito para permitir, por exemplo, que uma tab seja\n     adicionada pela simples manipulação do DOM.\n     */\n    this.mo?.disconnect();\n    this.mo = new MutationObserver(() => {\n      forceUpdate(this.el);\n    });\n    this.mo.observe(this.el, {childList: true});\n    this.mo.observe(this.el.querySelector('.alc-tabs'), {childList: true});\n\n\n    this.tabs.map((tab, i) => {\n      const tabpanel = tab.querySelector('[role=\"tabpanel\"]');\n\n      if (this.tabButtons.length <= i) {\n        return;\n      }\n\n      const button = this.tabButtons[i].querySelector('button');\n\n      if (!tabpanel.hasAttribute('id')) {\n        tabpanel.setAttribute('id', `tab_${i}`);\n      }\n      if (!button.hasAttribute('id')) {\n        button.setAttribute('id', `button_${i}`);\n      }\n\n      tabpanel.setAttribute('aria-labelledby', button.getAttribute('id'));\n      button.setAttribute('aria-controls', tabpanel.getAttribute('id'));\n    });\n\n    // this.handleScroll();\n  }\n\n  disconnectedCallback() {\n    this.mo?.disconnect();\n  }\n\n  render() {\n\n    let tabList: Array<HTMLElement>;\n\n    if (!this.hasButtonSlot) {\n      tabList = this.tabs.map((tab) => {\n        // Não parece ser um boa ideia criar esses elementos dinamicamente, dessa forma\n        // Fazendo assim, a inclusão de uma nova tab no DOM, por exemplo, não\n        // reflete automaticamente aqui, porque não ocorre o \"render\".\n        return (\n          <alc-tab-button tab={tab.tab}>\n            {tab.label}\n          </alc-tab-button>\n        );\n      });\n    }\n\n    logger.log('rendering', this.el, tabList);\n\n    return (\n      <Host\n        onAlcTabButtonClick={this.onTabClicked}\n        onAlcTabButtonNext={this.onTabButtonNext.bind(this)}\n        onAlcTabButtonPrevious={this.onTabButtonPrevious.bind(this)}\n      >\n        <div class=\"alc-tabs\">\n\n          <alc-scroll-panel hasFocus={false} scrollToElement={this.selectedTabButton} >\n            <div role=\"tablist\" ref={el => this.tabList = el} class=\"alc-tabs__tab-list\">\n              <slot name=\"button\" />\n              {tabList}\n            </div>\n          </alc-scroll-panel>\n\n          <slot />\n        </div>\n\n      </Host>\n    );\n  }\n\n}\n\nconst getTab = (tabs: HTMLAlcTabElement[], tab: string | HTMLAlcTabElement): HTMLAlcTabElement | undefined => {\n  const tabEl = (typeof tab === 'string')\n    ? tabs.find(t => t.tab === tab)\n    : tab;\n\n  if (!tabEl) {\n    logger.error(`tab with id: \"${tabEl}\" does not exist`);\n  }\n  return tabEl;\n};\n\nconst getTabButton = (buttons: HTMLAlcTabButtonElement[], tab: string): HTMLAlcTabButtonElement | undefined => {\n\n  const buttonEl = buttons.find(b => b.tab === tab);\n\n  if (!buttonEl) {\n    logger.error(`tab button with id: \"${buttonEl}\" does not exist`);\n  }\n  return buttonEl;\n};\n\n"],"mappings":"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","ignoreList":[]}