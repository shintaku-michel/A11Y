import { r as registerInstance, c as createEvent, h, H as Host } from './index-BuFKlV49.js';
import { g as getUniqueId } from './getUniqueId-BY09qPiz.js';
import { t as testAttributes } from './testAttributes-DKpd2q2s.js';

const alcTooltipCss = "[data-alc-theme=\"dark\"] alc-tooltip{--bg-color:var(--alc-color-neutral-90)}[data-alc-theme=\"light\"] alc-tooltip{--bg-color:var(--alc-color-neutral-5)}.alc-tooltip__content{border-radius:0.125rem;border-width:1px;border-color:var(--alc-color-border);background-color:var(--bg-color);padding-left:0.5rem;padding-right:0.5rem;padding-top:0.25rem;padding-bottom:0.25rem;font-size:0.875rem;line-height:1rem;color:var(--alc-color-text-secondary);width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}alc-tooltip .alc-popup__arrow{--arrow-size:var(--alc-spacing-03);height:var(--arrow-size);width:var(--arrow-size);border-color:var(--alc-color-border);background-color:var(--bg-color);border-bottom-width:var(--alc-border-width);border-right-width:var(--alc-border-width)}";

const AlcTooltip = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.alcShow = createEvent(this, "alc-show", 7);
        this.alcAfterShow = createEvent(this, "alc-after-show", 6);
        this.alcHide = createEvent(this, "alc-hide", 7);
        this.alcAfterHide = createEvent(this, "alc-after-hide", 7);
        this.contentId = null;
        this.hasClickedOrFocused = false;
        /**
        * Indica se o tooltip esta ativo ou não. Pode-se usar essa propriedade em vez dos métodos show/hide.
        */
        this.active = false;
        /**
        * Indica o conteudo textual do tooltip. Pode-se usar o slot em vez dessa propriedade.
        */
        this.content = null;
        /**
        * Define o posicionamento do tooltip.
        */
        this.placement = 'top';
        /**
        * Define como o tooltip vai ser ativado. Pode ser: `click` , `hover` , `focus` e/ou `manual`. Pode adicionar mais de um, separando por espaço. Ex.: 'hover focus'.
        */
        this.trigger = 'hover focus';
        /**
        * Define o posicionamento do tooltip.
        */
        this.strategy = 'absolute';
    }
    /**
     * Exibe o tooltip.
     * @returns O valor retornado é `true` se o tooltip foi realmente exibido com essa chamada ao método.
     */
    async show() {
        if (this.active)
            return false;
        const { defaultPrevented } = this.alcShow.emit({ from: 'method' });
        if (defaultPrevented) {
            return false;
        }
        this.active = true;
        return true;
    }
    /**
    * Fecha o tooltip.
    * @returns O valor retornado é `true` se o tooltip foi realmente dispensado com essa chamada ao método.
    */
    async hide() {
        if (!this.active)
            return false;
        const { defaultPrevented } = this.alcHide.emit({ from: 'method' });
        if (defaultPrevented) {
            return false;
        }
        this.active = false;
        return true;
    }
    ;
    watchActive(active) {
        if (active) {
            // Show
            this.alcAfterShow.emit();
        }
        else {
            // Hide
            this.alcAfterHide.emit();
        }
    }
    handleKeyDown(event) {
        var _a;
        if (event.key === 'Escape') {
            event.preventDefault();
            (_a = this.anchorEl) === null || _a === void 0 ? void 0 : _a.focus();
            this.handleHide('keyboard');
        }
    }
    handleFocus() {
        if (!this.hasTrigger('focus'))
            return;
        const opened = this.handleShow('focus');
        if (opened)
            this.hasClickedOrFocused = true;
    }
    handleBlur() {
        if (!this.hasTrigger('focus'))
            return;
        const closed = this.handleHide('focus');
        if (closed)
            this.hasClickedOrFocused = false;
    }
    handleMouseOver() {
        if (!this.hasTrigger('hover'))
            return;
        this.handleShow('hover');
    }
    handleMouseOut() {
        if (!this.hasTrigger('hover'))
            return;
        // Verifica se ja foi aberto por click ou foco para não fechar com hover
        if (this.hasClickedOrFocused)
            return;
        this.handleHide('hover');
    }
    handleClick() {
        if (!this.hasTrigger('click'))
            return;
        if (this.active) {
            // Hide
            const closed = this.handleHide('click');
            if (closed)
                this.hasClickedOrFocused = false;
        }
        else {
            // Show
            const opened = this.handleShow('click');
            if (opened)
                this.hasClickedOrFocused = true;
        }
    }
    componentWillLoad() {
        this.contentId = getUniqueId();
    }
    componentDidLoad() {
        if (this.anchorSlot) {
            const el = this.anchorSlot.assignedElements()[0];
            if (el instanceof HTMLElement) {
                this.anchorEl = el;
                this.anchorEl.setAttribute('aria-describedby', this.contentId);
                this.anchorEl.setAttribute('tabindex', '0');
            }
        }
    }
    async handleHide(type) {
        const { defaultPrevented } = this.alcHide.emit({ from: type });
        let closed = false;
        if (!defaultPrevented) {
            closed = await this.hide();
        }
        return closed;
    }
    async handleShow(type) {
        const { defaultPrevented } = this.alcShow.emit({ from: type });
        let opened = false;
        if (!defaultPrevented) {
            opened = await this.show();
        }
        return opened;
    }
    hasTrigger(triggerType) {
        const triggers = this.trigger.split(' ');
        return triggers.includes(triggerType);
    }
    render() {
        return (h(Host, { key: 'b0c78d43c4d9c151ffb324428231f3d8613f8af9' }, h("alc-popup", { key: 'e92d111b22fa9e003a7ac7a8e0312a44c94d5c8b', active: this.active, placement: this.placement, shift: true, flip: true, distance: 8, arrow: true, role: "tooltip", strategy: this.strategy }, h("div", Object.assign({ key: '264958b7e8045ffe845f990a92dcf27307713af6', slot: "anchor" }, testAttributes()), h("slot", { key: 'a76cf9f9d1f4f97b4375434ebbc41299892ca376', name: "trigger", ref: (el) => this.anchorSlot = el })), h("div", Object.assign({ key: '0f959b9b6533f7b6ab9ab4fb6448b12b7e560a2b', class: "alc-tooltip__content", id: this.contentId }, testAttributes()), h("slot", { key: '8e034dbfcfe8f5a2f513fb952570ff288c459f10' }, this.content)))));
    }
    static get watchers() { return {
        "active": ["watchActive"]
    }; }
};
AlcTooltip.style = alcTooltipCss;

export { AlcTooltip as alc_tooltip };
//# sourceMappingURL=alc-tooltip.entry.js.map

//# sourceMappingURL=alc-tooltip.entry.js.map