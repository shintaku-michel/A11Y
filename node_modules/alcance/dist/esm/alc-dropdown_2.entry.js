import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-BuFKlV49.js';
import { g as getFocusableElements } from './keydown-CsSB10gC.js';
import { g as getUniqueId } from './getUniqueId-BY09qPiz.js';
import { l as logger } from './logger-CZkdJRkw.js';

const alcDropdownCss = "[data-alc-theme=\"dark\"] alc-dropdown{--border-color:var(--alc-color-neutral-80)}[data-alc-theme=\"light\"] alc-dropdown{--border-color:var(--alc-color-neutral-10)}alc-dropdown{position:relative;display:inline-block}.alc-dropdown__content{overflow:auto;background-color:var(--alc-color-surface-primary);border-radius:0.25rem;border-width:1px;border-color:var(--border-color);--tw-shadow-color:#000000;--tw-shadow:var(--tw-shadow-colored);--tw-drop-shadow:drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));-webkit-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);max-height:inherit;}.alc-dropdown__content--opened{display:block}@-webkit-keyframes Scale{0%{opacity:0;-webkit-transform:scale(0.8);transform:scale(0.8)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes Scale{0%{opacity:0;-webkit-transform:scale(0.8);transform:scale(0.8)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}";

const AlcDropdown = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.alcShow = createEvent(this, "alc-show", 7);
        this.alcAfterShow = createEvent(this, "alc-after-show", 6);
        this.alcHide = createEvent(this, "alc-hide", 7);
        this.alcAfterHide = createEvent(this, "alc-after-hide", 6);
        this.hideOnEventsMap = new Map();
        /**
         * Indica se o dropdown esta aberto ou não. Pode-se usar essa propriedade em vez dos métodos show/hide.
         */
        this.open = false;
        /**
         * Nome do evento que, ao ocorrer no conteúdo do dropdown, vai fazer com que ele seja fechado.
         * Podem ser informados vários eventos, separados por um espaço em branco.
         */
        this.hideOn = '';
        this.handleAnchorClick = (event) => {
            var _a;
            if (!(event.target instanceof Node)) {
                return;
            }
            // Se o click foi no trigger (ou dentro dele)
            if ((_a = this.trigger) === null || _a === void 0 ? void 0 : _a.contains(event.target)) {
                this.toggleDropdown();
            }
        };
        this.toggleDropdown = async () => {
            this.open ? this.hide() : this.show();
        };
    }
    watchOpen() {
        if (this.trigger) {
            this.handleTriggerAriaExpanded();
            this.handleTriggerTabindex();
        }
    }
    watchHideOn() {
        // Remove todos os eventos anteriores
        this.hideOnEventsMap.forEach((listener, eventName) => {
            this.content.removeEventListener(eventName, listener);
            this.hideOnEventsMap.delete(eventName);
        });
        // Adiciona todos os novos eventos
        this.addHideOnListeners();
    }
    async handleKeydown(event) {
        if (!this.open)
            return;
        if (event.key !== 'Escape')
            return;
        if (event.defaultPrevented)
            return;
        event.preventDefault();
        await this.hide();
        this.handleTriggerFocus();
    }
    /**
     * Método para abrir o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente exibido com essa chamada ao método.
     */
    async show() {
        if (this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcShow.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = true;
        this.alcAfterShow.emit();
        return true;
    }
    /**
     * Método para fechar o dropdown.
     * @returns O valor retornado é `true` se o dropdown foi realmente oculto com essa chamada ao método.
     */
    async hide() {
        if (!this.open) {
            return false;
        }
        const { defaultPrevented } = this.alcHide.emit();
        if (defaultPrevented) {
            return false;
        }
        this.open = false;
        this.alcAfterHide.emit();
        return true;
    }
    handleTriggerFocus() {
        var _a;
        (_a = this.trigger) === null || _a === void 0 ? void 0 : _a.focus();
    }
    handleContentFocus() {
        const contentFirstFocusable = getFocusableElements(this.content)[0];
        if (!contentFirstFocusable)
            return;
        if (contentFirstFocusable instanceof HTMLElement) {
            contentFirstFocusable.focus();
        }
    }
    setTriggerAccessibility() {
        if (this.trigger.getAttribute('role') === null) {
            this.trigger.setAttribute('role', "button");
        }
        const contentElementChild = this.content.firstElementChild;
        if (this.trigger.getAttribute('aria-haspopup') === null) {
            const ariaHaspopup = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.role) === "menu" ? "menu" : "dialog";
            this.trigger.setAttribute('aria-haspopup', ariaHaspopup);
        }
        let id = (contentElementChild === null || contentElementChild === void 0 ? void 0 : contentElementChild.id) ? contentElementChild.id : getUniqueId();
        // Se não ter conteudo dentro, o id vai no alc-dropdown__content se não vai no conteudo
        if (!contentElementChild) {
            this.content.id = id;
        }
        else {
            contentElementChild.id = id;
        }
        this.trigger.setAttribute('aria-controls', id);
    }
    handleTriggerAriaExpanded() {
        this.trigger.ariaExpanded = `${this.open}`;
    }
    handleTriggerTabindex() {
        this.trigger.tabIndex = this.open ? -1 : this.originalTriggerTabindex;
    }
    async handleFocusOut(e) {
        const { relatedTarget } = e;
        const isNode = relatedTarget instanceof Node;
        /*
          OBSERVAÇÃO:
          Para que um clique qualquer dentro de content, mesmo se for um elemento não focalizável,
          não resulte em relatedTarget null, foi definido tabindex=-1 para o content.
          Se não fosse assim, um clique em um elemento não focalizável dentro de content
          resultaria no fechamento indesejado do dropdown.
        */
        if (isNode && this.el.contains(relatedTarget)) {
            return;
        }
        await this.hide();
    }
    handleCloseOn(e) {
        if (e.defaultPrevented) {
            return;
        }
        this.open = false;
    }
    addHideOnListeners() {
        const hideOn = this.hideOn.trim();
        // Nada a fazer se for um string vazia.
        if (!hideOn) {
            return;
        }
        const eventNames = hideOn.split(/\s+/);
        eventNames.forEach(eventName => {
            const listener = (e) => this.handleCloseOn(e);
            this.hideOnEventsMap.set(eventName, listener);
            this.content.addEventListener(eventName, listener);
        });
    }
    componentDidUpdate() {
        if (this.open) {
            // Quando o trigger for acionado por teclado para abrir o foco deve ir para o primeiro elemento focalizável dentro do conteúdo
            // Foi adicionado para tratar no componentDidUpdate pois no handleKeydown o dropdown ainda esta fechado, logo o 'elemento.focus()' não funciona
            // Aqui o componente ja foi renderizado com o novo estado.
            this.handleContentFocus();
        }
    }
    getTrigger() {
        let slot = null;
        let trigger = null;
        slot = this.el.querySelector('[slot="trigger"]');
        if (slot) {
            if (slot.tagName === 'BUTTON' || slot.getAttribute('role') === 'button') {
                // Trigger é o próprio slot se ele mesmo for o botão
                trigger = slot;
            }
            else {
                // Trigger é o primeiro botão encontrado dentro do slot (se existir)
                trigger = slot.querySelector('button, [role="button"]');
            }
        }
        if (trigger === null) {
            logger.warn(this.el, 'alc-dropdown não localizou um trigger válido. Slot deve ser ou conter um botão. Veja a documentação para mais detalhes.');
        }
        return trigger;
    }
    componentDidLoad() {
        this.trigger = this.getTrigger();
        if (this.trigger) {
            this.setTriggerAccessibility();
            this.handleTriggerAriaExpanded();
            this.originalTriggerTabindex = this.trigger.tabIndex;
        }
        // Adiciona close-on listeners
        this.addHideOnListeners();
    }
    render() {
        return (h(Host, { key: '2a3cb9758c23c1f7f895322bffa6893a4680e1e8' }, h("alc-popup", { key: '0c352d9d09c09df64e50c0561633120705875ef1', active: this.open, placement: "bottom-start", flip: true, shift: true, strategy: "fixed", onFocusout: this.handleFocusOut.bind(this), distance: 2 }, h("div", { key: '6b60a206a5a326e53c1f3afed07b0e53b52c9832', slot: "anchor", onClick: this.handleAnchorClick }, h("slot", { key: '528d7a27ebf5bdc884d89796d3aec84ae19e18e5', name: "trigger" })), h("div", { key: '2407874043bb9e9cabfaf9bc13751040f15f0c18', class: "alc-dropdown__content", ref: (el) => this.content = el, tabindex: '-1' }, h("slot", { key: 'ecd68a468c536a351baa3c5eb75fad9fbd88c2b4' })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["watchOpen"],
        "hideOn": ["watchHideOn"]
    }; }
};
AlcDropdown.style = alcDropdownCss;

const alcMenuCss = ".alc-menu{display:block;padding-top:0.5rem;padding-bottom:0.5rem;background-color:var(--alc-color-surface-primary)}";

const AlcMenu = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.hasFocus = false;
        this.getListItems = () => Array.from(this.hostElement.querySelectorAll('[role^=menuitem]'));
        this.includeFirstItemInTabNavigation = () => {
            this.items.forEach((item, pos) => {
                item.setAttribute('tabindex', pos === 0 ? '0' : '-1');
            });
        };
        this.removeAllItemsFromTabNavigation = () => {
            this.items.forEach(item => item.setAttribute('tabindex', '-1'));
        };
        this.setHasFocus = (hasFocus = true) => {
            this.hasFocus = hasFocus;
            if (hasFocus) {
                this.removeAllItemsFromTabNavigation();
            }
            else {
                this.includeFirstItemInTabNavigation();
            }
        };
    }
    async refresh() {
        this.items = this.getListItems();
        this.includeFirstItemInTabNavigation();
    }
    handleKeydown(event) {
        if ('ArrowDown' === event.key) {
            event.preventDefault();
            this.handleFocusedItemIndex();
            return;
        }
        if ('ArrowUp' === event.key) {
            event.preventDefault();
            this.handleFocusedItemIndex(-1);
            return;
        }
    }
    /**
     * Focar item recém-selecionado
     */
    handleAlcSelect(e) {
        const index = this.items.findIndex(item => item === e.target);
        if (index === null)
            return;
        this.handleFocusItem(index);
    }
    handleFocusin({ target }) {
        // Se já tem o foco, nada a fazer
        if (this.hasFocus) {
            return;
        }
        if (this.hostElement.contains(target)) {
            this.setHasFocus(true);
        }
    }
    handleFocusout({ relatedTarget }) {
        if (!this.hostElement.contains(relatedTarget)) {
            this.setHasFocus(false);
        }
    }
    handleFocusedItemIndex(direction = 1) {
        const currentIndex = this.items.indexOf(document.activeElement);
        if (currentIndex === -1)
            return;
        let nextIndex = currentIndex + direction;
        const itemsLength = this.items.length - 1;
        if (nextIndex > itemsLength) {
            nextIndex = 0;
        }
        if (nextIndex < 0) {
            nextIndex = itemsLength;
        }
        this.handleFocusItem(nextIndex);
    }
    handleFocusItem(index) {
        const item = this.items[index];
        if (item instanceof HTMLElement) {
            // Seta foco no atual
            item.focus();
        }
    }
    componentDidRender() {
        this.items = this.getListItems();
    }
    componentDidLoad() {
        this.includeFirstItemInTabNavigation();
    }
    render() {
        return (h(Host, { key: '2aa137629ce5187b9191d9885a0b716d51ef4861', role: "menu", class: "alc-menu" }, h("slot", { key: '6442d2320bb9c5b2f83859688fb464ac5ab903da' })));
    }
    get hostElement() { return getElement(this); }
};
AlcMenu.style = alcMenuCss;

export { AlcDropdown as alc_dropdown, AlcMenu as alc_menu };
//# sourceMappingURL=alc-dropdown.alc-menu.entry.js.map

//# sourceMappingURL=alc-dropdown_2.entry.js.map